# 线程管理
## 线程的创建和运行
* 继承Thread类，并且覆盖run方法。
* 实现Runnable接口，使用带参数的Thread构造器来创建Thread对象。

## 线程信息的获取和设置
ID，Name，Priority，Status

## 线程的中断
isInterrupted()不能改变interrupted属性的值，interrupted()能设置interrupted的属性为false。

## 线程中断的控制
InterruptedException异常，检查到线程中断的时候，抛出异常，在run()方法中捕获并处理异常。

## 线程的休眠和恢复
调用sleep()方法之后，线程会释放CPU且不再继续执行任务。

休眠中线程被中断，该方法立即抛出InterruptedException异常。

yield()方法，通知JVM这个线程对象可以释放CPU了，并不保证遵循这个要求。通常只做调试使用。

## 等待线程的终止
当一个线程对象的join()方法被调用时，调用它的线程将被挂起，直到这个线程对象完成它的任务。

## 守护线程的创建和运行
setDemon()方法只能在start()方法被调用之前设置。

## 线程局部变量的使用
ThreadLocal()

InheritableThreadLocal 如果一个线程是从其他某个线程中创建的，这个类将提供继承的值。

## 线程的分组
ThreadGroup类表示一组线程。

## 使用工厂类创建线程
ThreadFactory接口，实现了线程对象工厂。

该接口只有一个方法newThread，以Runnable接口对象作为参数并且返回一个线程对象。

# 线程同步基础
## Synchronized
如果一个对象已用synchronized关键字声明，那么只有一个执行线程被允许访问它，如果其他某个线程试图访问这个对象的其他方法，它将被挂起，直到第一个线程执行完成正在运行的方法。

每一个用synchronized关键字声明的方法都是临界区，同一个对象的临界区在同一时间只有一个允许被访问。

synchronized声明的静态方法，同时只能够被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。

## 使用非依赖属性实现同步
使用synchronized关键字来保护代码块时，必须把对象引用作为传入参数。使用this来引用执行方法所属的对象，还可以使用其他对象。

## 在同步代码中使用条件
一个线程调用wait()方法时，JVM将这个线程置入休眠，并且释放控制这个同步代码块的对象,同时允许其他线程执行这个对象控制的其他同步代码块。为了唤醒这个线程，必须在这个对象控制的某个同步代码块中调用notify()或者notifyAll()方法。

## 使用锁实现同步
基于Lock接口及其实现类如ReentrantLock，提供了更多的好处。

* 支持灵活的同步代码块结构，只能在同一个synchronized结构中获取和释放控制。Lock接口允许实现更复杂的临界区结构。
* Lock提供了更多功能，tryLock()方法，试图获取锁，如果锁已被其他线程获取，它将返回false并继续往下执行代码。而使用synchronized关键字时，如果线程试图执行一个已被其他线程正在执行的同步代码块，此线程将被挂起。
* Lock接口允许分离读和写操作，允许多个读线程和只有一个写线程。
* 相比synchronized关键字，Lock接口具有更好的性能。

## 使用读写锁实现同步数据访问
ReadWriteLock接口和实现类ReentrantReadWriteLock，这个类有两个锁，一个是读操作锁，一个是写操作锁。

## 锁的公平性
ReentrantLock和ReentrantReadWriteLock类的构造器都含有一个布尔参数fair，默认是false非公平模式，true为公平模式

## 在锁中使用多条件
一个锁可能关联一个或者多个条件，这些条件通过Condition接口声明，目的是允许线程获取锁并且查看等待的某一个条件是否满足，如果不满足就挂起直到某个线程唤醒它们。Condition接口提供了挂起和唤起线程的机制。

与锁绑定的所有条件对象都是通过Lock接口声明的newCondition方法创建的。在使用条件的时候，比须获取这个条件绑定的锁，所以带条件的代码必须在调用Lock对象的lock()方法和unlock()方法之间。

当线程调用条件的await()方法时，它将自动释放这个条件绑定的锁，其他某个线程才可以获取这个锁并且执行相同的操作，或者执行这个锁保护的另一个临界区代码。

线程调用了条件对象的signal()或者signalAll()方法后，一个或者多个在该条件上挂起的线程将被唤醒。

awaitUninterruptibly()不可中断的，这个线程将休眠直到其他某个线程调用了将它挂起的条件的sigal()或signalAll()方法。

awaitUntil(Date date)直到发生以下情况之一之前，线程将一直处于休眠状态：

* 其他某个线程中断当前线程。
* 其他某个线程调用了将它挂起的条件的signal()或signalAll()方法。
* 指定的最后期限到了。

# 线程同步辅助类
* 信号量Semaphore，是一种计数器，用来保护一个或者多个共享资源的访问。
* CountDownLatch 在完成一组正在其他线程中执行的操作之前，它允许线程一直等待。
* CyclicBarrier 它允许多个线程在某个集合点处进行相互等待。
* Phaser 它把并发任务分成多个阶段运行，在开始下一阶段之前，当前阶段中的所有线程都必须执行完成，Java7 新特性
* Exchanger 提供了两个线程之间的数据交换点。

## 资源的并发访问控制
如果线程要访问一个共享资源，它必须先获得信号量，如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。

否则如果信号量计数器等于0，信号量将会把线程置入休眠直至计数器大于0。

线程使用完某个共享资源时，信号量必须被释放，使信号量的内部计数器加1。


