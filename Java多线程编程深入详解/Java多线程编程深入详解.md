# 多进程多线程概述

Java 多线程的实现有两种方式：

* 继承Thread类
* 实现Runnable接口

# 多线程详解

## 继承Thread创建线程

* 继承Thread类
* 重写run方法
* 调用线程的start方法

Thread使用的是Template Design

# 线程的状态

四个基本状态：

* 初始化（被创建）
* 运行状态
* 冻结状态
* 终止状态（死亡）

## 线程的初始化
就是创建了一个线程，实例化一个Thread的子类。

## 线程的运行状态
创建完线程之后，显式调用了start方法。

## 线程的冻结状态
线程被调用了sleep方法或者wait方法之后，放弃了CPU的执行权。可以继续回到运行状态，也可以直接到死亡状态，比如被中断或者出现异常。

## 线程的死亡状态
出现了致命的异常导致线程被死亡，或者是线程执行逻辑执行完毕线程正常死亡。

# 实现Runnable接口创建线程

一个线程只能被启动一次。

# Runnable和Thread的区别

* Runnable是一个可执行任务的标识，Thread才是线程所有API的体现
* 继承了Thread就没法继承其他的类，实现了Runnable接口也可以继承其他类并且实现其他接口。
* 将任务执行单元和线程的执行控制区分开，才是引入Runnable最主要的目的。

# 线程中的策略模式

# 线程的同步

## 同步代码块

* 所谓加锁，就是为了防止多个线程同时操作一份数据，如果多个线程操作的数据都是各自的，没有必要加锁。
* 共享数据的锁对于访问他们的线程来说必须是同一份，否则锁只能是私有的锁，各锁各的，起不到保护共享数据的目的。
* 锁的定义可以时任意一个对象，该对象可以不参与任何运算，只要保证在访问的多个线程看起来是唯一的即可。

## 同步方法
方法名前加synchronized

## this锁与static锁

同步方法其实用到的锁时this锁。

静态锁，锁是类字节码信息，如果一个类的方法位静态方法，那我们需要通过该类的class信息进行加锁

## 线程的休眠

sleep 让当前的运行线程进入休眠状态，也就是主动放弃CPU执行权

```
//在指定的毫秒数内让当前正在执行的线程休眠，暂停执行
sleep(long millis);
//在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠，暂停执行
sleep(long millis,int nanos)
```









