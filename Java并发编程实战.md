# Java并发编程实战

## 什么是线程安全

* 无状态对象一定是线程安全的

## 原子性

### 竞态条件


应尽可能的使用现有的线程安全对象,如AtomicLong来管理类的状态.

## 加锁机制

### 内置锁
Java提供一种内置锁机制来支持原子性:同步代码块.

同步代码块包括两部分:一个作为锁的对象引用,一个作为由这个锁保护的代码块.

synchronized

以synchronized来修饰的方法就是一种横跨整个方法体的同步代码块,其中该同步代码块的锁就是方法调用所在的对象.

静态synchronized方法以Class对象作为锁.

### 重入
内置锁是可重入的,如果某个线程试图获得一个已由他自己持有的锁,这个请求就会成功.

重入意味着获取锁的操作粒度是线程,而不是调用.

## 用锁来保护状态

一种常见加锁约定:将所有可变状态都封装在对象内部,通过对象的内置锁对所有访问可变状态的代码路径进行同步,是的在该对象上不会发生并发访问.Vector和其他同步集合类都使用了这种模式.

## 活跃性与性能

# 对象的共享
## 可见性
### 失效数据

### 非原子的64位操作

### 加锁与可见性

### volatile变量
确保将变量的更新操作通知到其他线程.

volatile变量是一种比sychronized关键字更轻量级的同步机制.

volatile变量通常用做某个操作完成,发生中断或者状态的标志.

加锁机制既可以确保可见性又可以确保原子性,而volatile变量只能确保可见性.

当且仅当满足一下所有条件时,才应该使用volatile变量:

* 对变量的写入操作不依赖变量的当前值,或者你能确保只有单个线程更新变量的值.
* 该变量不会与其他状态变量一起纳入不变性条件中
* 在访问变量时不需要加锁

## 发布与逸出

## 线程封闭

### Ad-hoc线程封闭
是指维护线程封闭性的职责完全由程序实现来承担.

### 栈封闭
是线程封闭的一个特例,在栈封闭中,只能通过局部变量才能访问对象.

### ThreadLocal类
通常用于防止对可变的单实例变量或全局变量进行共享.

## 不变性
不可变对象一定是线程安全的.

满足以下条件时,对象才是不可变的:

* 对象创建后其状态就不能修改
* 对象所有域都是final类型
* 对象是正确创建的,在对象创建期间,this引用没有逸出

### final域


## 安全发布

### 不可变对象与初始化安全性

### 安全发布的常用模式

# 对象的组合


# 基础构建模块
## 同步容器类
### 同步容器类的问题

## 并发容器

### ConcurrentHashMap

分段锁Lock Stripiing

提供的迭代器不会抛出ConcurrentModificationException

### CopyOnWriteArrayList
写入时复制

## 阻塞队列和生产者-消费者模式

### 闭锁(Latch)
闭锁的作用相当于一扇门:在闭锁到达结束状态之前,这扇门一直是关闭的,并且没有任何线程能通过,当到达结束状态时,这扇门会打开并允许所有的线程通过.当闭锁达到结束状态后,将不会再改变状态,因此这扇门将永远保持打开状态.

CountDownLatch

### FutureTask

### 信号量

### 栅栏Barrier
所有线程必须同时到达栅栏位置才能继续执行.

# 任务执行
## 在线程中执行任务

## Executor框架
该框架能支持多种不同类型的任务执行策略.

提供了中标准的方法将任务的提交过程与执行过程解耦开来,用Runnable来表示任务.

### 线程池

newFixedThreadPool 将创建一个固定长度的线程池,每当提交一个任务时就创建一个线程,指导达到线程池的最大数量.

newCachedThreadPool 创建一个可缓存的线程池,如果线程池当前规模超过了处理需求时,将回收空闲空间的线程,当需求增加时,则可以添加新的线程,线程池的规模不存在任何限制.

newSingleThreadExecutor 是一个单线程的Executor,它创建单个工作者线程来执行任务.

newScheduledThreadPool 创建一个固定长度的线程池,而且以延迟或定时的方式来执行任务,类似于Timer.

### Executor的生命周期

ExecutorService添加了一些用于生命周期管理的方法

生命周期有3种状态:运行,关闭,已终止.

### 延迟任务与周期任务

### CompletionService

# 取消与关闭

# 线程池的使用
