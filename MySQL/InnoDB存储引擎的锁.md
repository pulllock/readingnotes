# InnoDB存储引擎支持的锁

InnoDB存储引擎支持的锁：

- 表级锁
- 行级锁

锁的对象是事务

MyISAM存储引擎支持的锁：

- 表级锁

# 行级锁

InnoDB存储引擎中行锁是针对索引的，也就是加锁的对象都是索引或者索引区间。

InnoDB存储引擎支持两种行级锁：

- 共享锁（S Lock）：允许事务读取一行数据
- 排它锁（X Lock）：允许事务删除或更新一行数据

行级锁的兼容性：

- 共享锁和共享锁不互斥
- 共享锁和排它锁互斥
- 排它锁和排它锁互斥

行级锁的兼容性使用表格示例如下：

|     | 排它锁 | 共享锁 |
| --- | --- | --- |
| 排它锁 | 互斥  | 互斥  |
| 共享锁 | 互斥  | 不互斥 |


# 表级锁/意向锁

InnoDB存储引擎支持多粒度锁定，允许事务在行级别的锁和表级别的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎中使用意向锁（Intention Lock）来支持，也就是意向锁即为表级别的锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。

支持两种意向锁：

- 意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁
- 意向排它锁（IX Lock）：事务想要获得一张表中某几行的排它锁

由于InnoDB存储引擎支持的是行级别的锁，因此除了全表扫描以外，意向锁不会阻塞其他任何请求。

表级意向锁和行级锁的兼容性：

- 意向共享锁和意向共享锁不互斥
- 意向共享锁和意向排它锁不互斥
- 意向共享锁和行级共享锁不互斥
- 意向共享锁和行级排它锁互斥
- 意向排它锁和意向排它锁不互斥
- 意向排它锁和行级共享锁互斥
- 意向排它锁和行级排它锁互斥

表级意向锁和行级锁的兼容性使用表格示例如下：

|       | 意向共享锁 | 意向排它锁 | 行级共享锁 | 行级排它锁 |
| ----- | ----- | ----- | ----- | ----- |
| 意向共享锁 | 不互斥   | 不互斥   | 不互斥   | 互斥    |
| 意向排它锁 | 不互斥   | 不互斥   | 互斥    | 互斥    |
| 行级共享锁 | 不互斥   | 互斥    | 不互斥   | 互斥    |
| 行级排它锁 | 互斥    | 互斥    | 互斥    | 互斥    |

# 一致性非锁定读

一致性非锁定读是指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据，如果读取的行正在执行delete或update操作，这时读取操作不会等待行上锁的释放，而是回去读取行的一个快照数据。读取的快照数据是指该行的之前版本的数据，是通过undo段来完成的，读取快照不需要上锁。

快照数据是当前行的历史版本，每个行记录可能会有多个版本也就是会有多个快照数据，这种技术为：行多版本技术，对应的并发控制成功多版本并发控制（MVCC）。

# 一致性锁定读

InnoDB存储引擎对于select语句支持两种一致性锁定读操作：

- `select ... for update;`：该操作会对读取的行记录加一个排它锁，其他事务不能在该行记录上加任何锁
- `select ... lock in share mode;`：该操作会对读取的行记录加一个共享锁，其他事务可以在该行记录上加共享锁，如果要加排它锁则会被阻塞。

上述两种一致性锁定读操作需要在事务中进行。


# 自增长与AUTO-INC锁

在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器，对含有自增长计数器的表进行插入操作时，这个计数器会被初始化，插入操作会依据这个计数器的值加1赋予自增长列，这种实现方式叫做AUTO-INC Locking。

在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。

AUTO-INC锁是一种特殊的表锁机制，锁不是在一个事务完成后进行释放，而是在完成对自增长值插入的SQL语句之后立即释放。

AUTO-INC的缺点：虽然一定程度上提高了并发插入效率，但还是存在一些性能问题：

- 对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入完成
- 对于`insert ... select`的大数据量的插入会影响插入的性能，因为另一个事务中的插入会被阻塞

从MySQL 5.1.22版本开始，InnoDB存储引擎中提供了一种轻量级互斥量的自增长实现机制，大大提高了自增长值插入的性能。可以通过`innodb_autoinc_lock_mode`来控制自增长模式，默认值为1，可用值如下：

- 0：这个是通过表锁的AUTO-INC Locking方式，不建议使用
- 1：这个是默认值，在该模式下根据不同的插入方式有如下几种情况：
	- 对于简单的插入：insert、replace等能在插入前就确定插入行数的语句（不包含insert ... on duplicate key update这类的语句），会使用互斥量去对内存中的计数器进行累加操作。
	- 对于批量的插入：insert ... select、replace ... select、load data等在插入前不能确定插入行数的语句，还是会使用传统的表锁AUTO-INC Locking的的方式。
- 2：该模式下对所有的插入操作：insert、replace、insert ... select、replace ... select、load data的自增长值的产生都是通过互斥量，而不是使用表锁AUTO-INC Locking的方式。这样性能好，在并发插入的情况下会导致自增长不是连续的。

# 行锁的三种算法

InnoDB存储引擎有3种行锁的算法：

- Record Lock：单个行记录上的锁，总是会**锁住索引**记录，如果建表的时候没有设置任何索引，InnoDB存储引擎会使用隐式的主键来进行锁定。
- Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
- Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身

采用Next-Key Lock算法的锁定技术称为Next-Key Locking，设计的目的是为了解决幻读问题。使用该技术锁定的是一个范围，假如一个索引有10、11、13、20这四个值，该索引可能被Next-Key Locking的区间为：`(负无穷大, 10]、(10, 11]、(11, 13]、(13, 20]、(20, 正无穷大)`。当查询的索引含有唯一索引（唯一索引需要是完全部的唯一索引，如果是多个列组成，则需要使用全部的列组成的唯一索引）时，InnoDB存储引擎会将Next-Key Lock降级为Record Lock，仅仅锁住索引本身，而不是范围。

Gap Lock的作用是为了阻止多个事务将记录插入到同一范围内，导致幻读问题的产生。

# 阻塞和超时

默认情况下InnoDB存储引擎不会回滚超时引发的错误异常。

# 参考

- 《MySQL技术内幕：InnoDB存储引擎》第二版