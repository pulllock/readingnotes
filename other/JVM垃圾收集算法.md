# 如何判断对象可以被回收/判断对象存活的算法

## 引用计数法

引用计数法是给每个对象设置一个计数器，当有地方引用这个对象的时候，就将这个计数器加一，当引用时效的时候就将这个计数器减一。当计数器为0的时候，就代表这个对象不再被使用，可以回收。

引用计数算法实现简单，效率高，但是无法解决循环引用的问题。

## 可达性分析算法

可达性分析算法使用一系列的“GC Roots”对象作为起始点，从这些起始点开始向下搜索，搜索通过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连，说明这个对象是不可用的。

可以作为GC Roots对象有：

- 虚拟机栈（栈帧中的局部变量表）中引用的对象。
- 方法区中静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象。

# JVM垃圾收集算法

## 标记-清除算法

标记-清除算法（Mark-Sweep），分为两个阶段：标记阶段和清除阶段。在标记阶段，首先根据根节点标记所有的可达对象，未被标记的对象就是可以回收的对象。在标记完成之后，清除阶段就可以清除掉所有的垃圾对象。

缺点：

- 效率问题，标记和清除阶段的效率都不高。
- 空间问题，清除后会产生大量的不连续的内存碎片，如果需要分配大的对象，可能由于找不到足够的连续内存而提前触发另一次垃圾收集动作。

## 标记-整理算法

标记整理算法与标记清除算法类似，只不过在标记完成后，不是对可回收对象进行清除，而是将所有存活对象移向一端，然后清理掉边界以外的内存。

缺点：

- 效率问题，标记和整理的过程效率都不高。

优点：

- 相对于标记-清除算法，解决了内存碎片问题。

## 复制算法

复制算法可以解决效率问题，它将可用内存按照容量划分成大小相等的两块，每次只使用其中的一块，当一块内存用完了，就将还存活着的对象移到另外一块上，然后把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配不用考虑内存碎片的问题。

优点：

- 效率高，没有内存碎片。

缺点：

- 需要浪费一半的内存空间。
- 如果对象的存活率较高，需要进行较多的复制，效率会变的很低。

## 分代收集算法

根据对象存活周期的不同，将内存划分为几块，一般把Java堆分为新生代和老年代，然后根据各个年代的特点采用不同的垃圾收集算法。在新生代中，每次垃圾回收都会有大批的对象死去，只有少量对象存活，可以选用复制算法；在老年代中对象存活率较高，没有额外空间进行担保，就必须使用标记-清除或者标记-清理来进行回收。

## 对象分配策略

- 对象优先在Eden区域分配，如果对象过大直接分配到老年代。
- 长期存活对象进入老年代。
