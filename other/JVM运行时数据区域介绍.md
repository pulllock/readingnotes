此处的内容是根据Java虚拟机规范（Java SE 7）相关内容以及深入理解Java虚拟机等做的总结。可能有不对的地方。了解这些区域，可以从总体上看下虚拟机内部是怎么构造的，网上也有相关的图片介绍，可以适当的记下图片内容，这样可以有一个立体的感受，更容易记忆。

Java虚拟机定义了程序运行期间使用到的运行时数据区域，其中一些与虚拟机生命周期相同，另外一些与线程的生命周期相同。JVM运行时数据区域分为：

* 程序计数器（Program Counter）
* Java虚拟机栈（Java Virtual Machine Stack）
* 堆（Heap）
* 方法区（Method Area）
* 本地方法栈（Native Method Stack）

# 程序计数器（Program Counter）
程序计数器是线程私有的，每条线程都有自己的程序计数器。

Java虚拟机是支持多线程的，多线程是通过线程的轮流切换来实现的，也就是说每次切换都需要在上次停顿的地方重新开始运行，这时候就需要程序计数器来保存当前线程正在执行的字节码指令的地址，切换到该线程的时候，就能知道该执行哪一个字节码指令了。

如果一个线程正在执行的方法是Java方法，程序计数器保存的是Java虚拟机正在执行的字节码指令的地址；如果正在执行的方法是native的，程序计数器的值为undefined。

# Java虚拟机栈（Java Virtual Machine Stack）
Java虚拟机栈也是线程私有的，与线程同时创建，用于存储栈帧（Fremas），栈帧用来存储局部变量，操作数栈、指向当前方法所属类的运行时常量池、处理动态链接、方法返回值和异常分派。方法从调用到执行完成的过程就对应着一个栈帧从入栈到出栈的过程。

Java虚拟机栈可以被实现为固定大小的，此时每一条线程的Java虚拟机栈在线程创建的时候容量就已经确定；还可以被实现为根据计算动态扩展和收缩的。

Java虚拟机栈可能会发生异常：

* 如果线程请求的栈容量超过Java虚拟机栈允许的最大容量，会抛出StackOverflowError异常。
* 如果虚拟机栈可动态扩展，申请不到足够的内存去完成扩展，或者建立新线程时没有足够的内存去创建虚拟机栈，会抛出OutOfMemoryError异常。

## 栈帧
栈帧随着方法的调用而创建，随着方法的结束（正常或者异常结束）而销毁，是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接（Dynamic Linking）、方法返回值和异常分派（Dispatch Exception）。

栈帧存在于Java虚拟机栈中，栈帧中包含局部变量表、操作数栈和指向当前方法所属类的运行时常量池的引用。

局部变量表和操作数栈的容量在编译期确定，通过方法的Code属性保存并提供给栈帧使用。栈帧的容量大小仅仅取决于Java虚拟机的实现和方法调用时可分配的内存。

## 局部变量表
局部变量表存在于栈帧中，长度在编译期决定，存储在类和接口的二进制表示中，也就是存储在方法的Code属性中并提供给栈帧使用。

局部变量表可以保存类型为boolean、byte、char、short、int、float、reference、returnAddress，而long和double类型需要两个局部变量表来存储。

局部变量表还用来完成方法调用时参数的传递，一个方法被调用，它的参数会传递至0开始的连续局部变量表位置上。对于实例方法来说，局部变量表第0个位置是用来存储实例方法所在对象的引用，也就是我们通常说的this。

## 操作数栈
操作数栈存在于栈帧中，是一个LIFO的栈，长度由编译期确定，也是存储在方法的Code属性中提供给栈帧使用。

操作数栈会有一个确定的栈深度，一个long或者double类型的数据会占用两个单位的栈深度，其他数据类型则会占用一个单位深度。

## 动态链接
栈帧内部包含一个指向运行时常量池的引用（运行时常量池的解释在下面，可以先看一下运行时常量池），这个引用用来支持当前方法的代码实现动态链接。

Class文件中，一个方法调用其他方法或者访问其成员变量是通过符号引用来表示的，动态链接作用就是将符号引用转换为实际的直接引用。

# 堆（Heap）
堆是各个线程共享的运行时内存区域，也是所有的类实例和数组对象分配内存的区域。堆在虚拟机启动的时候被创建，存储了被垃圾收集器所管理的各种对象。

堆的容量可以是固定大小的，也可以是动态扩展和自动收缩的。Java堆的内存不需要保证是连续的。

Java堆可能发生异常情况：

* 实际所需的堆超过了最大容量，抛出OutOfMemoryError异常。

# 方法区（Method Area）
方法区也是被各个线程所共享的运行时内存区域。用于存储类的结构信息，例如运行时常量池、字段、方法数据、构造函数、普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。

方法区在虚拟机启动的时候被创建，是堆的逻辑组成部分。方法区的容量可以是固定大小的，也可以是动态扩展和自动收缩的。内存空间不需要保证是连续的。

方法区可能发生异常的情况：

* 方法区的内存不能满足内存分配时，会抛出OutOfMemoryError异常。

## 运行时常量池
运行时常量池分配在方法区中，类和接口被加载到虚拟机之后，运行时常量池就被创建了。

运行时常量池是类或接口的常量池的运行时表示形式，包括从编译期可知的数值字面量和运行期解析后才能获得的方法或字段引用。

可能会发生异常的情况：

* 构造运行时常量池所需的内存空间超过了方法区能提供的最大值，会抛出OutOfMemoryError异常。

# 本地方法栈（Native Method Stack）
用来支持native方法。跟虚拟机栈功能类似。本地方法栈被实现成固定大小或者是动态扩展和收缩的。

可能会发生的异常情况：

* 如果线程请求的栈容量超过本地方法栈允许的最大容量，会抛出StackOverflowError异常。
* 如果本地方法栈可动态扩展，申请不到足够的内存去完成扩展，或者建立新线程时没有足够的内存去创建对应的本地方法栈，会抛出OutOfMemoryError异常。

# 简要总结
程序计数器为线程私有，用来指示程序运行时的位置。

Java虚拟机栈是线程私有的，用来存储局部变量表等，出栈入栈对应着方法的结束开始。

堆是线程共享的区域，虚拟机启动时创建，创建的实例对象和数组都分配在堆上。

方法区是线程共享的区域，虚拟机启动时创建，用来存储类的信息，常量字段等等。

本地方法栈用来执行本地方法的。
