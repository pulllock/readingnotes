# MVC简介

面试的时候被问到关于MVC相关的知识，才发现自己只会说出来什么叫MVC，但是其详细的东西自己却无法顺利的表述出来，特在此记录下。

## MVC基础
MVC是Model-View-Controller的简称，是一种软件架构模式，也是经过很多人的长期实践最后得出来的很适合软件开发的一种模式。

M（Model）模型层，这应该是最底层的一层，这一层中我们需要处理的是业务逻辑和数据等等方面的东西，包括核心业务代码的编写，访问数据库或者文件进行数据处理，数据库等很多方面。

V（View）视图层，这一层是最上面的一层，用户可以看到并且进行操作的地方。

C（Controller）控制层，这部分处于中间，负责转发和处理请求，接收来自视图层用户的操作等，负责处理和转发；会根据情况传递到模型层，模型层做完处理之后，再由控制层根据实际情况返回到视图层去展示。另外一种情况是在模型层处理完之后，可以直接将结果返回给视图层。

### Web MVC
Web开发中的MVC模式跟标准的MVC模式一样，但是Web MVC不能在模型层将结果主动推送给视图层，因为Web模式下是基于请求-响应模型的。其他的定义和流程都和标准MVC模式是一样的。

## Web如何进化到MVC
这里的Web进化主要利用Java开发方面的历程作说明，当然最开始的CGI不算是Java中的过程，但是还是需要它作为开头。

大致的历程为：`CGI --> Servlet --> JSP --> Model1 --> Model2`

### CGI
由于没有使用过CGI这种技术做过开发，只能使用维基上的定义来简单说明下。CGI是通用网关接口（Common Gateway Interface）的简称，多使用Perl语言编写，接受用户的请求，然后根据请求的返回给用户HTML页面。但是每次CGI请求都会生成一个新的进程去处理，对服务器来说压力太大，请求大的时候很快就会垮掉。

### Servlet
Servlet技术和CGI技术的作用是一样的，但是Servlet是Java体系中最早用来解决Web的技术。Java是平台无关的，同样Servlet也是，它比CGI更加的高高效，CGI针对请求生成的是进程级别的，而Servlet生成的是线程级别的。

#### Servlet的生命周期

1. 加载和实例化

	Servlet容器负责加载和实例化Servlet。
	
2. 初始化
	
	Servlet在实例化之后，会调用init()方法初始化。
	
3. 服务
	
	Servlet的service()方法对请求进行处理。
	
4. 销毁
	
	Servlet的destory()方法用来销毁Servlet实例，释放资源等。

#### Servlet缺点
Servlet技术让Java有了Web方面的更好的选择，后来的技术很大一部分都是在Servlet的基础上发展来的。但是Servlet直接做开发还是显得很繁琐，我在使用Servlet做开发的时候遇到过很多的弊端，直接点说就是Servlet做开发时，把MVC的分层直接放到一起了，甚至html代码也得在Servlet里面直接输出。这样的做法对于后期维护修改或者页面的调试很是麻烦。现在直接用Servlet做开发已经很少用了，但是还是得作为必须要去学习的基础知识。

### JSP
JSP技术使用在html页面中嵌入脚本语言的方式来处理Servlet技术的不足，相对于Servlet来说有了很多进步，开发页面更加方便简单。但是实质上JSP最后还是被编译成了Servlet，表现逻辑以及控制和模型等方面的逻辑还是混杂在了一起，看起来好像是跟Servlet反过来一样。这种做法同样不可取。

### Model1
这种技术是JSP和JavaBean的组合，相对于JSP来说只是将业务逻辑放到了单独的JavaBean中去，可以理解为是JSP的增强，对JSP页面进行了简化，但是JSP页面仍然将表现逻辑，控制逻辑，业务逻辑等混杂到一起。这种做法仍然不可取。

### Model2
Model2采用JSP+Servlet+JavaBean来实现，其实这时候就可以认为是我们的Web MVC模型了，在实际使用中也是使用的这种模式。

JSP 使用html和jsp的标签来负责实现表现层；Servlet负责接收用户的请求，转交给模型层进行处理，返回结果给视图层等功能；JavaBean负责业务逻辑的处理，也就是模型层的功能。

到这里为止，开发过程中遇到的方式都已经介绍完了，也走到了MVC模式这一步。下面会简单介绍下MVC的框架相关知识。

## Spring Web MVC
先看一下Spring官方的一张请求处理流程图：
![请求处理流程](MVC简介/springmvc.png)
再看一下具体的流程：

1. 第一步，用户发送请求（Incoming request）到前端控制器（Front controller）
2. 前端控制器（Front controller）根据实际的请求信息来决定把请求委托给具体的页面控制器（Controller）。页面控制器用来处理实际的请求内容，直接返回或者需要Model层进行数据处理。
3. 页面控制器（Controller）接收到请求后进行处理，处理完成后返回model数据，并委托给前端控制器（Front controller）进行渲染。
4. 前端控制器（Front controller）根据逻辑视图名和model数据选择视图模板（View template）进行渲染，渲染完成后返回给前端控制器（Front controller）。
5. 最后前端控制器将渲染后的最终结果返回给用户。

对应具体的源码分析不在此做过多说明。



