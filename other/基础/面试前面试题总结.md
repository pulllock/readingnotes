# 抽象类与接口的区别
抽象类是用来抽象子类的通用特性，不能被实例化，只能用作子类的超类。

接口是抽象方法的集合，一个类实现了接口，那么它就继承了这个接口所有的抽象方法。

* 抽象类可以有默认的方法实现，接口不存在方法的实现，是完全抽象的。
* 抽象类的子类用extends来继承，如果子类不是抽象类的话，需要实现抽象类中所有声明的方法；实现接口需要用implements，需要提供接口中声明的所有方法的实现。
* 抽象类可以有构造器；接口不能有构造器。
* 抽象类可以使用public，protected，default，接口只能是public
* 只可以继承一个抽象类，可以实现多个接口。
* Jdk8中接口中可以有默认方法和静态方法。

# String，StringBuilder，StringBuffer

String是字符串常量，StringBuffer是线程安全的字符串变量，StringBuilder是线程不安全的字符串变量。

对于很少改变内容的字符串，String效率高，对于经常改变内容的字符串，使用StringBuilder效率高，但是它只适用单线程，多线程使用StringBuffer。

String类型是不可变类型，每次对String类型进行改变的时候，都等于生成了一个新的String对象，将指针指向新的String对象。StringBuffer每次结果都是对对象本身修改，而不是生产新对象。

# 泛型的概念和使用
泛型是jdk1.5的新特性，泛型意味着编写的代码可以被不同类型的对象所重用。

引入泛型的主要目标：

* 类型安全
* 消除强制类型转换

泛型的本质是参数化类型，参数类型可以用在类，接口和方法中。

## 泛型的擦除
编译器对带有泛型的代码进行编译的时候，会执行类型检查和类型推断，然后生产普通的不带泛型的字节码。这叫做类型擦除。

# ArrayList，Vector，LinkedList区别

ArrayList基于数组实现，相比于数组可自动扩容。但是底层还是对数组的操作，所以对于查找的速度要比较好，对于插入和删除的速度就比较慢，需要移动数组元素或者重新拷贝数组。不是线程安全的。

LinkedList基于双向链表实现，所以对比ArrayList来说，查找元素会比较慢，因为需要遍历链表，而对于插入删除元素等操作性能比较好，只需要移动指针就可。不是线程安全的。

Vector 功能和ArrayList基本相同，是以前版本遗留下来的类，现在基本没用过。不过是线程安全的。

# HashMap，HashTable，ConcurrentHashMap
HashMap基于哈希的键值映射，内部以数组和链表来存储数据，每个HashMap默认有一个大小为16的Bucket桶，也就是数组，需要存储数据的时候根据key的哈希值来确定存储在哪个位置，找到位置之后把key和value封装成Entry存储到对应数组位置上。如果确定存储位置的时候发生了冲突，采用链表的方式来解决冲突，将key的哈希值相同的元素组成一个链表存储在对应数组的位置上，jdk1.8之后当链表长度大于8的时候采用红黑树来存储。查找元素的时候需要先根据key哈希值找到数组对应的位置，然后根据key的equals来在链表中查找元素。不是线程安全的。

ConcurrentHashMap是jdk1.5之后加入的并发包中的类，是HashMap对应的多线程的版本。相比于HashMap有更好的线程安全性。内部也是由数组和链表组成，不过比HashMap稍微复杂一点。采用了分段锁的机制，每个ConcurrentHashMap默认有16个Segment，所以理想情况默认可以有16个线程来同时访问它。存储元素时候，需要先根据key来确定元素存储在哪个segment上，然后确定存储在哪个Bucket上面，这后面的操作跟HashMap都类似了。定位到Segment之后需要修改操作时候，会获取当前段的锁，其他段的操作并不会受到影响，这几保证了并发性。

HashTable也是基于哈希的键值映射，跟HashMap实现类似，只不过是线程安全的，对于修改操作会进行同步。属于遗留下来的类，很少使用。

## 为什么ConcurrentHashMap是弱一致的
ConcurrentHashMap的get方法是弱一致的，当往ConcurrentHashMap中添加一个元素的时候，有可能不是立马就可使用get方法得到。

## ConcurrentHashMap分段锁
允许多个修改操作并发执行，使用锁分离技术，使用了多个锁来控制对hash表不同部分进行修改。ConcurrentHashMap内部使用段来表示不同的部分。每段都有自己的锁，只要多个修改不发生在同一个段上，就可以并发执行。

# Collections.synchronizedXX 方法的原理
可以将List和Map等变成同步的线程安全的，就是把其中的修改等操作使用Synchronized关键字进行同步，保证了线程安全。

# ThreadLocal的作用
ThreadLocal为每个线程都创建一个变量的副本，每个线程可以修改自己的副本，不影响其他线程的副本。

## 变量副本存储在哪里？
保存在线程中。

# Java反射机制，原理
Java反射机制能够在运行时候获取类的任何信息，变量，方法，修饰符，等等。对于任意一个对象，都能够调用它的任意方法和属性。反射的性能比较低，安全性也不高。反射也能在运行时刻调用对象的方法，创建新类对象等。

主要作用：获取到运行时类的方法和字段等相关信息；创建某个类的实例；取得字段引用直接获取和设置对象字段。

## Class.forName作用，为什么要用
能够根据给定的类名的字符串构造一个对象。

## 通过反射有几种方法可以实例化Class类对象
1. Class.forName()方法
2. 类名.Class
3. 对象.getClass()方法

## 什么是反射
反射是在运行时可动态获得类的属性和方法，能够知道类的所有信息，并且能够动态调用对象的属性和方法，这种能够动态获取和调用对象方法的功能叫做反射机制。

## Java反射的作用
运行时获取类的各种信息，运行时调用任意对象的方法，运行时构造一个类的对象。

## 反射机制的优点
可以实现动态创建对象和编译。

## 怎样提高反射效率
尽量不要getMethod后遍历，使用getMethod(methodName)方法。

使用缓存。

系统启动阶段使用反射。

使用高性能反射库。
# 注解
也叫元数据，jdk1.5开始的新特性，用于对代码进行说明。主要作用是生成文档，编译检查，编译时动态处理，运行时动态处理。注解是在编译时由编译器处理，编译器会对注解符号处理并附加到class结构中。

# Java内存模型

主存和工作内存。

# JVM内存模型
Java内存模型往往是指Java虚拟机运行时内存模型。Java运行时数据区域包括：程序计数器，堆，本地方法栈，Java虚拟机栈，方法区。

程序计数器，用来指示正在执行的字节码指令的地址，每个线程都有一个程序计数器。

堆，所有对象的分配以及数组的分配都在堆上，是JVM中占用空间最大的区域，每个线程都能访问堆。

Java虚拟机栈，线程私有的，存储栈帧，栈帧用来存储局部变量，方法执行从开始到结束，就对应着栈帧从入栈到出栈的过程。

本地方法栈，支持native方法，跟Java虚拟机栈类似。

方法区，各个线程共享的区域，用来存放类的结构信息，运行时常量池，字段等。

# Java垃圾回收机制
Java的垃圾回收机制应该从两个方面去解释：1.对象需要被回收的算法2.回收时候的垃圾收集算法。3.垃圾收集器。4.什么时候触发GC。

## 对象需要被回收的算法

对象需要被回收的算法，引用计数算法和可达性分析算法。引用计数算法很难解决循环依赖的问题。可达性分析算法中的Root可以包括：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象。

## 回收时候的垃圾收集算法

回收时候的垃圾收集算法，包括标记-清除算法，复制算法，标记整理算法，分代收集算法。

标记清除算法，首先从根集合扫描，标记出需要被回收的对象，标记完成后统一回收所有被标记的对象。标记清除算法容易产生内存碎片，效率也不高，回收时候需要应用暂停执行。

复制算法，将内存分为两块大小相等的空间，每次只是用其中的一块，当内存使用满了，需要回收时，需要把还存活的对象复制到另外一块内存上面去，然后把已使用的内存空间清理掉。这样不容易产生内存碎片，但是每次只能使用一半的内存。

标记整理算法，标记阶段和标记清除算法一样，标记完成后，将存活的对象移向一端，然后清理掉其他的内存。不会产生内存碎片，适用于对象存活数较多，回收少的情况。

分代收集算法，是将以上几种算法结合，根据对象存活周期的不同，将内存划分为几块，分别使用垃圾回收算法。可以分为新生代和老年代，新生代中大部分的对象都需要被回收，可以采用复制算法，老年代会有很少的对象需要回收，可以采用标记整理算法。

新生代又可以分为一个较大的Eden空间和两个较小的Survivor空间，每次只使用Eden空间和一块Survivor空间。新创建的对象放在Eden空间中，每次垃圾回收需要将存活的对象放到空的Survivor空间，然后清除Eden空间和使用的Survivor空间。

## 垃圾收集器
Serial收集器，ParNew收集器，Parallel Scavenge收集器，Serial Old收集器，Parallel Old收集器，CMS收集器，G1收集器

## 什么时候触发GC
堆上分配内存不足的时候触发，堆内存达到一定量的时候触发，调用System.gc等操作时候触发，准备抛OOM异常之前触发。

# Java多线程
## 实现线程的几种方法
1. 实现Runnable接口
2. 继承Thread类
3. 使用并发库的线程池

## 停止正在运行的线程
1. 设置标志位
2. 发生阻塞，调用interrupt方法

## sleep()和wait()的区别
sleep方法是Thread类的，使线程暂停执行，但是不会释放所持有的锁，等到指定时间的时候会恢复执行；wait是Object类的，使线程暂停等待，它会释放锁，需要等待notify或者notifyAll方法去唤醒。

## Java多线程间通讯协作
wait notify notifyAll

# Java Concurrent
## 什么是可重入锁
java.util.concurrent.lock 中的Lock框架是锁的抽象，允许把锁当做java类，不是作为语言级别的特性，这样可以为锁的多种实现留下空间。ReentrantLock是可重入锁，实现了Lock接口，拥有和synchronized相同的语义，但是添加了锁投票，定时锁等候，可中断锁等候等特性。性能更好。

ReentrantLock拥有与锁相关的计数器，如果拥有锁的某个线程再次获取到锁，计数器就加1，需要释放两次才能获得释放。

## synchronized和Lock
synchronized和Lock拥有相同的语义，Lock增加了锁投票，锁等候，可中断锁等候等特性，Lock必须在finally中释放。

## CopyOnWriteArrayList使用场景
适合读操作远大于写操作的场景。

## 如何让一段程序并发执行，最后汇总结果

使用CountDownLatch或者CyclicBarrier都可以，CyclicBarrier在关口出将多个线程执行结果汇总，而CountDownLatch允许多个线程执行完毕之后向总线程汇报结果。

fork/join框架，fork把大任务分解成多个小任务，然后汇总多个小任务的结果得到最终结果。使用一个双端队列，当线程空闲时从双端队列的另一端领取任务。


额外：Semaphore 控制同事访问的线程的数量。

## 如何合理配置Java线程池

1. CPU密集型任务，可以少配置线程数，大概和CPU数目相当，可使每个线程都在执行任务。
2. IO密集型，大部分线程都阻塞，需要多配置线程数，2倍的CPU数。

## 有界队列和无界队列
一般配置有界队列，可能有爆发性增长的使用无界队列。

## 多读少写的场景使用哪个并发容器？
CopyOnWriteArrayList，适合多读少写，写时会大面积复制数组，写的性能差。


# 线程安全
## volatile作用，说明应用场景

volatile拥有synchronized的可见性，不具备原子性，保证多个线程读取变量的时候是最新值。

使用场景，对变量的写操作不依赖当前值，该变量没有包含在具有其他变量的不变式中。

## 说明下Java内存模型以及工作流程
Java运行时内存模型包括程序计数器，堆，Java虚拟机栈，本地方法栈，方法区。程序计数器记录正在执行的字节码指令地址，每个线程都有程序计数器。堆是虚拟机中占用内存最大的一块，所有对象实例和数组的分配都在堆上，所有线程所公用的。Java虚拟机栈，用来存储局部变量，存放栈帧，出栈入栈就对应方法的开始和结束，线程私有的。本地方法栈用来执行本地方法。方法区，用来存放类结构信息，运行时常量池等，是所有线程共享的区域。

工作流程：Java中所有对象成员变量都存储在主存中，每个线程多有自己的工作内存，工作内存中保存的是主存中变量的副本，操作都在工作内存中进行。
1. 获取对象监视器锁。2清空工作内存数据，从主存中拷贝到工作内存。3.执行代码等操作。4.工作内存刷新到主存中。5.释放锁。

# Java中的锁
## 读写锁适用什么场景？
适合多读少些的场景，读写锁可以同时有多个读操作并发执行，写操作只能有一个线程来操作。

## 什么时候使用可重入锁？
重入锁是指某一个线程中可以多次获得同一把锁，在线程中多次操作有锁的方法。

## 什么场景下可使用volatile替换Synchronized？
在保证共享资源的可见性的时候可以使用volatile替代。synchronized保证原子性，一致性，可见性。volatile用于新值不依赖旧值的时候。


# JVM相关
## Java引用的四种状态
强引用，软引用，弱引用，虚引用。

强引用，使用的最多的引用，new一个对象，使用一个引用指向它，这就是强引用。一个对象具有强引用，垃圾回收器不会回收该对象，虚拟机宁可抛出OOM异常，也不会回收强引用。

软引用，如果一个对象具有软引用，内存足够时，垃圾回收器不会回收它，只有当内存不足时，才会回收这些对象。软引用可以用来实现内存敏感的高速缓存。

弱引用，弱引用有更短暂的生命周期，每次GC，只要发现有软引用就会被回收。

虚引用，任何时候都可能被回收，主要用来跟踪对象被垃圾回收器回收的活动。

## Java中内存的划分
程序计数器，堆，Java虚拟机栈，本地方法栈，方法区。

程序计数器，记录当前正在执行的方法字节码指令的位置，保证线程切换后能恢复到原来的执行位置。

堆，所有对象分配的地方，虚拟机中最大的位置。

Java虚拟机栈，每个方法被调用的时候都会创建一个栈帧，栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。局部变量表存放的是编译期可知的基本数据类型，对象引用类型。

本地方法栈，为执行本地方法服务。

方法区，存储被虚拟机加载的类信息，常量，静态变量，静态方法等。

运行时常量池，是方法区的一部分。

## Java中对象在内存中的状态
可达的，可恢复的，不可达的

## 判断对象死亡的方法
引用计数法，可达性分析法

可达性分析法，设立若干的根对象，当任何一个根对象到某一个对象均不可达时，认为这个对象是可被回收的。

可以作为根的对象有：栈中引用的对象，方法区中的静态成员，方法区中的常量引用的对象，本地方法栈中的JNI引用的对象。

## 垃圾回收算法
标记清除，复制，标记整理，分代收集。

标记清除，通过根节点，标记可达对象，所有未被标记的对象就是可被回收的，标记完成后清理未被标记的对象，标记清除效率不高，容易产生内存碎片。

复制算法，将内存空间分为两块，一次只是用一块，在垃圾回收时，将正在使用的内存中的存活对象的复制到另外一块内存中去，清除当前的内存空间。不会有内存碎片问题，但是会有一半的内存空间闲置，还需要复制对象，效率不好。

标记整理，从根节点开始标记可达对象，然后将可达对象移向内存的一端，把剩余的对象清空。不会产生内存碎片，但是需要移动对象，效率不高。

分代收集，是上面算法的综合，新生代的对象存活率很低，采用复制算法比较好，老年代存活率高，采用标记清除或者标记整理比较好。

## 垃圾收集器
serial收集器，串行收集器，单线程，收集时候必须暂停其他工作线程，stop the world，一直到垃圾收集完成。简单高效，client模式下的选择。

ParNew收集器，是Serial收集器的多线程版本，是server模式下的首选新生代收集器。

ParNew Scanvenge收集器，关注吞吐量。

G1收集器。

CMS收集器，初始标记，并发标记，重新标记，并发清除。

## Java堆内存划分
根据对象的存活率，Java堆可分为，新生代，老年代，永久带。

新生代分为Eden区域和两个Survivor区域。

Minor GC 发生在新生代中的垃圾收集，采用复制算法。

Full GC 发生在老年代的垃圾收集，使用标记整理或者标记清除算法。

永久带是方法区。

## 类加载机制
虚拟机把描述类的数据从Class文件加载到内存。并对数据进行校验，转换解析和初始化，最终形成可被虚拟机使用的Java类型。

类加载的过程：加载，链接，初始化。其中链接又包括验证，准备，解析。

### 加载
把class文件读入到内存，并创建java.lang.Class对象。作为方法区这个类的数据访问的入口。

### 链接

* 验证：校验文件格式。语法语义等。
* 准备：给静态变量做默认初始化，并在方法区分配内存。
* 解析：将符号引用替换为直接引用。

### 初始化
创建类的实例，调用类的静态变量（final static常量不会对类进行显式初始化），调用静态方法，初始化类的子类，反射，java虚拟机启动被表明为启动类的类。

## JVM调优
### JVM模式应用场景

1. server模式和client模式，如果不配置，应用服务器会根据硬件配置自动选择。server模式启动比较慢，但是运行期速度得到优化，client启动快，但是运行期没有server快，适合个人开发和测试。
2. Garbage Collector Policy，jdk1.5提供了三种GC，原来的SerialGC和新的ParallelGC和CMS。SerialGC串行，ParallelGC多线程并行管理和回收垃圾对象，CMS采用并发的方式来管理和回收垃圾，降低了垃圾回收的暂停时间。

## JVM内存监控
使用工具观察：

1. 堆信息，年轻代和老年代划分是否合理；内存泄漏；垃圾回收算法设置是否合理。
2. 线程监控，线程信息监控，系统线程数量；线程状态监控，每个线程的状态；Dump线程详细信息；死锁检查。
3. CPU分析，CPU热点，检查哪些方法占用CPU时间；内存热点，检查哪些对象在系统中数量最大。

## JVM内存泄漏问题
内存泄漏是系统资源在错误使用情况下，导致使用完的资源无法被回收，从而导致新的资源分配请求无法完成，引发系统错误。

### 系统崩溃前的一些现象

1. 每次垃圾回收时间越来越长，FullGC的时间也变长了。
2. FullGC次数越来越多。
3. 老年代的内存越来越大并且每次FullGC后老年代内存没有被释放。
4. 之后系统会无法响应新请求，逐渐到达OOM的临界值。

### 内存泄漏或者系统崩溃原因

1. 无法释放对象，对象没有被释放。
2. Memory参数分配不足，内存不够用，需要增加Heap来满足需要。

### 容易出现问题的场景

1. 应用的缓存或者Collection，避免大量消耗和无限增加。
2. 生命周期较长的对象，尽量减短对象的生命周期。
3. 类似JDBC的连接池，在使用完对象后要释放并返回，不然会造成池的不断增大。

### 如何查找内存问题

1. 分析Dump文件
2. 工具分析

### JVM内存分析，查看内存满的情况

1. 老年代堆空间被占满
	
	异常`java.lang.OutOfMemoryError: Java heap space`，典型的内存泄漏方式，所有堆空间都被无法回收的垃圾占满，虚拟机无法再分配新空间。
	
	解决，根据垃圾回收前后情况对比，同时根据对象引用情况分析。

2. 永久代被占满
	
	异常`java.lang.OutOfMemoryError: PermGen space`，Perm空间被占满，无法为新的class分配存储空间而引发的异常。主要原因是大量动态反射生成的类不断被加载，最终导致Perm区被占满。
	
	解决：可设置参数`-XX:MaxPermSize=128M`。

3. 堆栈溢出
	
	异常` java.lang.StackOverflowError`，一般是递归没返回或者循环调用造成的。

4. 线程堆栈满
	
	异常，`Fatal: Stack size too small`，Java中线程的大小是有限制的，JDK5以后是1M，当线程空间满了之后将会出现异常。
	
	解决，增加线程栈的大小`-Xss2m`，无法解决根本问题，检查是否有泄漏的代码。

5. 系统内存被占满
	
	异常，`java.lang.OutOfMemoryError: unable to create new native thread`，操作系统没有足够的资源来产生这个线程。
	
	解决，重新设计减少线程数量；线程数量不能减少的话通过`-Xss`减小单个线程大小。

## JVM调优开始

### 分代内存默认值
堆大小=新生代+老年代

新生代=Eden+两个Survivor

```
新生代:老年代=1:2

-XX:NewRatio指定比例

Eden:from:to = 8:1:1

每次只使用Eden和一个Survivor，新生代利用率为90%
```

### 分配规则
#### 新生代Eden设计
所有创建的新对象都在Eden，大部分对象都是朝生夕死，当Eden区满了之后，启动Stop-The-World的GC，或为minor GC，采取数次复制Copy-Collection到Survivor，经过几次收集，寿命不断延长的对象从Survivor进入老年代。

#### survivor空间
每个survivor空间也要足够大到能够容纳活跃的请求对象和保有对象。

#### 老年代设计
老年的GC成为major GC，就是full GC。要避免频繁的Full GC。老年代区域比较大，对象生命周期比较长，标记整理需要一定时间，所以GC时间比较长。minor GC可能引发Full GC，当Eden+from 的空间大于老年代剩余空间时，会引发Full GC。

#### 永久代设计
该区域比较稳定，主要用于存放classloader信息，比如类信息和method信息。默认64M。容易出现`OutOfMemoryError: PermGen space`。2G以上内存设置`-XX:PermSize=128M -XX:PermSize=160M`

### 内存参数设置

```
-Xms,-Xmx设置heap大小的最小值和最大值。

-Xmn设置新生代大小。

-Xss设置每个线程堆栈大小

-XX:NewSize新生代大小

-XX:NewRatio新生代与老年代的比例

-XX:SurvivorRatio新生代中Eden与Survivor的比值。默认为8。

-XX:PremSize永久代的初始大小

-XX:MaxPermSize 永久代的最大值

-XX:+PrintGCDetails打印GC信息

-XX:+HeapDumpOnOutOfMemoryError 发生内存溢出时Dump当前内存堆转储快照
```

测试：

```
package me.cxis.test.jvm;

/**
 * Created by cheng.xi on 17/01/2017.
 * -Xms60m
 * -Xmx60m
 * -Xmn20m
 * -XX:NewRatio=2( 若 Xms = Xmx, 并且设定了 Xmn, 那么该项配置就不需要配置了 )
 * -XX:SurvivorRatio=8
 * -XX:PermSize=30m
 * -XX:MaxPermSize=30m
 * -XX:+PrintGCDetails
 */
public class Test {

    public static void main(String[] args) {
        new Test().doTest();
    }

    private void doTest() {
        Integer M = new Integer(1024 * 1024 * 1);//兆M
        byte[] bytes = new byte[1 * M];//1M的内存空间
        bytes = null;//断开引用
        System.gc();//通知GC收集垃圾
        bytes = new byte[1 * M];//1M
        bytes = new byte[1 * M];//1M
        System.gc();
        System.out.println();
    }
}

```

结果：

```
[GC (System.gc()) [PSYoungGen: 3318K->496K(18432K)] 3318K->504K(59392K), 0.0019761 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=30m; support was removed in 8.0
[Full GC (System.gc()) [PSYoungGen: 496K->0K(18432K)] [ParOldGen: 8K->406K(40960K)] 504K->406K(59392K), [Metaspace: 2826K->2826K(1056768K)], 0.0080247 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=30m; support was removed in 8.0
[GC (System.gc()) [PSYoungGen: 2703K->1152K(18432K)] 3109K->1558K(59392K), 0.0016069 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 1152K->0K(18432K)] [ParOldGen: 406K->1410K(40960K)] 1558K->1410K(59392K), [Metaspace: 2842K->2842K(1056768K)], 0.0112824 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 

Heap
 PSYoungGen      total 18432K, used 1147K [0x00000007bec00000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 16384K, 7% used [0x00000007bec00000,0x00000007bed1eda8,0x00000007bfc00000)
  from space 2048K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007c0000000)
  to   space 2048K, 0% used [0x00000007bfc00000,0x00000007bfc00000,0x00000007bfe00000)
 ParOldGen       total 40960K, used 1410K [0x00000007bc400000, 0x00000007bec00000, 0x00000007bec00000)
  object space 40960K, 3% used [0x00000007bc400000,0x00000007bc560af0,0x00000007bec00000)
 Metaspace       used 2863K, capacity 4494K, committed 4864K, reserved 1056768K
  class space    used 311K, capacity 386K, committed 512K, reserved 1048576K

```

分析：

新生代18432K（18M），eden 16384K（16M），from和to2048k（2M）

`新生代=eden+from+to=16+2+2=20M`。

设置的`SurvivorRatio=8`，所以`eden=8/10*20=16M`,`from=to=1/10*20=2M`。

老年代的大小为40960k（40M），堆大小设置的是60M，新生代为20M，所以`老年代=60-20=40M`。

jdk8中永久带已经取消了，变成了Metaspace元数据空间。

每次调 System.gc()，是先进行 Minor GC，然后再进行 Full GC。

第一次触发Minor GC `PSYoungGen: 3318K->496K(18432K)] 3318K->504K(59392K)`之前申请的1M空间已经被回收。

第一次触发Full GC `PSYoungGen: 496K->0K(18432K)`新生代变成0了，`ParOldGen: 8K->406K(40960K)`，Full GC之后老年代变大了，这是清空了新生代，然后新生代中存活的对象提前进入了老年代。

第二次Minor GC`PSYoungGen: 2703K->1152K(18432K)`第二次的1M被回收，第三次的1M没有被回收。

第二次触发Full GC`PSYoungGen: 1152K->0K(18432K)`新生代被清空，`ParOldGen: 406K->1410K(40960K)`老年代增大，新生代中存活的对象提前进入了老年代。

### JVM性能优化
要达到的目的：

1. 低开销
2. 低停顿时间
3. 有效的空间利用率

优化GC的目标：

1. GC的时间足够小
2. GC的次数足够少
3. 发生Full GC的周期足够长

#### 策略

1. 堆大小设置

## JVM结构

## 类加载原理
	

# NIO
NIO增加了四种抽象数据类型，Buffer，Charset，Channels，Selector。

## ByteBuffer
### 如何创建ByteBuffer
使用allocate()或者allocateDirect()方法。

### 如何对ByteBuffer进行读写
向ByteBuffer中写入数据：

* 使用channel.read(byteBuffer);
* 使用ByteBuffer的put()方法

从ByteBuffer中读取数据：

* 使用channel.read(byteBuffer);
* 使用ByteBuffer的get()方法。

### ByteBuffer的字节序是什么？
字节序是ByteOrder，可以对数据大端和小端进行切换。

### 直接缓存器和非直接缓存器的区别
直接缓存器通过Buffer.allocateDirect()来创建，存在于jvm之外的内存中，非直接缓存器的内存在jvm堆的内存中。

### ByteBuffer和StringBuffer
ByteBuffer构建缓存用的，StringBuffer用来构造可变的字符串。

# 数据库

## left join、right join、inner join的区别
left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行

## 数据库索引
### 为什么要创建索引

1. 能大大加快检索数据的速度
2. 能加速表与表之间的连接
3. 能减少分组和排序查询的时间

### 索引的缺点

1. 创建和维护索引需要花费时间，随着数据量的增加而增加
2. 索引需要占用物理空间，聚簇索引占用的更大
3. 当对表中数据进行增删改的操作时，索引也需要维护

### 什么时候创建索引

1. 在需要经常搜索的列上，可以加快搜索的速度
2. 在经常使用连接的列上，可以加快连接的速度
3. 在经常需要根据范围搜索的列上，因为索引已经排序，指定范围是连续的
4. 在经常需要排序的列上添加索引，索引已经排序，可以加快排序查询时间

## 索引的分类
聚簇索引和非聚簇索引

聚簇索引的顺序就是数据的物理存储顺序，一个表只能有一个聚簇索引。

非聚簇索引的顺序与数据物理排序无关。


## 乐观锁和悲观锁
悲观锁，对数据的修改持悲观态度，有对数据的修改操作时，需要锁定数据，其他修改该数据的时候无法获得，只有等当前操作完成之后，才能进行，效率不高，需要数据库的支持。

乐观锁，对数据的修改持乐观态度，一般通过添加版本号或者时间戳来解决。每次修改数据先比较版本号，然后才决定要不要提交数据。

## 数据库事务特性
ACID 原子性，一致性，隔离性，持久性。

## 数据库事务的隔离级别

* READ UNCOMMITED 未提交读，产生脏读。
* READ COMMITED 提交读 不可重复读。
* REPETABEL READ 可重复读
* SERIZELABEL 序列化的

# Spring
## Spring优点

1. 降低了组件之间的耦合性，实现了模块间的解耦
2. 提供了多种服务，很容易的就能实现事务管理，消息服务等
3. 提供了AOP和IOC的实现
4. 独立于各个应用服务器
5. 开发更加容易

## Spring AOP
面向切面编程，实现AOP有两种方式：动态代理，在运行期拦截数据流进行包装；静态织入，在编译期的时候，将代码织入到相关地方实现。Spring AOP采用的是动态代理的方式。

使用AOP可以很容的实现权限拦截，程序监控，日志等等功能，Spring的声明式事务管理就是使用的AOP。

## Spring IOC
IOC 控制反转，反射和动态代理。

## Spring事务管理
### 7种传播级别

1. PROPAGATION_REQUIRED，默认的事务传播级别，如果上下文已经存在事务，就加入到事务中执行，如果上下文不存在事务，则新建事务执行。
2. PROPAGATION_SUPPORTS，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。
3. PROPAGATION_MANDATORY，要求上下文必须要存在事务否则就会抛异常。
4. PROPAGATION_REQUIRES_NEW，每次都会新建一个事务，同时将上下文中的事务挂起，执行当前新建事务完成后，上下文事务恢复在执行。
5. PROPAGATION_NOT_SUPPORTED，上下文存在事务，则挂起事务，结束后恢复上下文事务。
6. PROPAGATION_NEVER，上下文不能存在事务，有事务就抛异常
7. PROPAGATION_NESTED，嵌套级别，如果上下文存在事务，则嵌套执行事务，不存在，就新建事务。

### 5种隔离级别

1. ISOLATION_DEFAULT，使用数据库的默认隔离级别。
2. ISOLATION_READ_UNCOMMITTED，未提交读，可能导致脏读，幻读，不可重复读。
3. ISOLATION_READ_COMMITTED，提交读，可能导致幻读和不可重复读。
4. ISOLATION_REPEATABLE_READ，可重复读，可能导致幻读。
5. ISOLATION_SERIAIZABLE，可序列化的

## Spring Bean的生命周期

1. 读取xml配置文件实例化Bean
2. 根据Bean的定义设置属性值
3. 如果实现了BeanNameAware接口，将Bean的id传给setBeanName()方法
4. 如果实现了BeanFactoryAware接口，将beanFactory传给setBeanFactory()方法
5. Bean的使用
6. Bean的销毁



## Spring MVC
### 优缺点
方法级别的拦截，拦截到方法后根据参数上的注解，把request数据注入进去。一个方法对应一个request上下文。容易实现restful风格的url。


# Java创建对象的过程

1. 检测类是否被加载
2. 为对象分配内存
3. 为对象的内存空间初始化零值
4. 对对象进行其他设置
5. 执行init方法

# Dubbo
Dubbo用来做分布式服务管理。

## Dubbo原理
远程调用。

## Dubbo中zookeeper做注册中心，如果注册中心集群都挂掉，发布者和订阅者之间还能通信么？
能，Dubbo启动时会从zookeeper拉取生产者的地址接口等数据，缓存在本地，每次调用可以按照本地存储的地址进行调用。

# Zookeeper
## Zookeeper的用途
Zookeeper是一个分布式应用协调系统，用来完成统一命名服务，状态同步服务，集群管理，分布式应用配置项的管理等。

# restful的优缺点
透明性，暴露资源存在。充分利用 HTTP 协议本身语义。无状态，这点非常重要。在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了复杂度。HTTP 本身提供了丰富的内容协商手段，无论是缓存，还是资源修改的乐观并发控制，都可以以业务无关的中间件来实现

# XSS
跨站脚本攻击，页面输入非法脚本，存储到数据库，重新渲染到页面时执行，可获取用户信息，提交到其他站，收集用户信息等。

可以过滤特殊字符或者转义。

# 分布式事务
两阶段提交通常被用来解决分布式事务的问题，一般分为协调器和事务执行者。应用发送请求到事务协调器，协调器写入到本地日志，然后向所有的事务执行者发消息。执行者接受到消息后执行事务，但不提交，返回成功信息，并写日志。协调器收到返回消息后发送提交的消息，执行者再提交事务。

两阶段提交性能太差。

## 使用消息队列避免分布式事务

## 分库分表，使用分布式事务
可以使用redis或者zookeeper来实现锁。 

# POST和GET的区别

1. get把参数包含在url中，post通过request body传递参数。
2. get在浏览器回退是无害的，post会再次提交请求
3. get参数会被保留在浏览器历史记录里，post中参数不会被保留
4. get在url中传送的长度是有限制的，post无限制
5. get不安全，请求参数直接暴露在url中。

GET，POST都是TCP请求，请求过程有些不同：

1. GET请求，浏览器会把http header和data一并发送出去，服务器响应，返回数据；
2. POST请求，浏览器先发送header，服务器响应100，浏览器再发送data，服务器响应，返回数据

# Java定时器
Timer类能够定时执行任务。TimerTask表示定时执行某一项任务。只能按照某一个频度去执行，不能指定时间。

ScheduledExecutorService实现定时任务。

Quartz，也是一个定时器。

Spring带的task也是一个定时器

# 高并发场景需要考虑的问题

1. 对频繁操作的表行，要加上乐观锁。
2. 表设计尽量采用分库
3. 事务加到service层，保证可同时回滚
4. 方法的并发加上Synchronized关键字
5. 静态资源使用CDN
6. 使用消息队列
7. 使用缓存

# 数据库调优

1. 索引优化，避免对索引字段进行计算，避免在索引字段使用`not,<>,!=`，避免在索引字段使用 is null 和is not null，避免使用函数，避免进行数据类型转换
2. sql语句优化，查询不用*，少用子查询，尽量避免在复杂查询里面使用`LIKE '%param1%'`。不要在子查询中使用count()求和
3. 分库分表

# Java异常

* 运行时异常 Runtime exception
* 被检查的异常Checked exception

# WebSocket
是html5的新协议，实现了浏览器与服务器全双工通信，建立在传输层TCP之上。

之前为了实现即时通讯，需要使用轮询，会占用很多带宽。

## WebSocket握手过程

1. 浏览器与WebSocket服务器通过TCP三次握手建立连接。
2. TCP连接建立成功后，浏览器通过http协议传送WebSocket的版本号，原始地址，主机地址等。
3. WebSocket服务器收到浏览器发来的请求后，接受本地握手链接，给出数据回复，采用http协议。
4. 浏览器收到回复的数据包后触发onopen消息，可以通过send接口开始发送数据了。

# 缓存
##缓存使用场景
缓存一些验证信息，验证码，session等。缓存热点数据。缓存经常查询需要但是不经常变动的数据加快查询速度。

## Redis和Memcache的区别

1. 存储方式，Memcache只把数据存储在内存中，数据不能超过内存大小；Redis有部分存储在硬盘上，能保证数据的持久化。
2. 数据支持类型，Memcache只支持键值对，Redis支持键值对，sets，lists等等。
3. 底层模型不同，使用了不同的内存分配机制，通信协议也不同。

## Redis支持的数据类型

1. strings 简单字符串，底层使用sds实现。
2. lists简单列表，底层使用双向链表或者压缩列表实现。
3. sets无序set，底层使用intset或hashtable
4. sorted sets 底层使用压缩列表或者跳跃表加哈希实现。
5. hashes，哈希表

## Redis使用场景

1. 会话缓存，redis提供持久化，缓存token，对热点数据进行缓存，需要设置过期时间。
2. 全页缓存
3. 队列
4. 实现计数器，INCR是原子的操作
5. 分布式锁

## Redis分片
跟分库分表差不多吧，需要实现路由等。

# 高并发量网站解决方案

1. html静态化
2. 图片服务器分离
3. 负载均衡
4. 缓存
5. 数据库集群，分库分表
6. CDN加速
7. 分布式

# ActiveMQ原理


# 单点登录的实现原理
在一个多系统共存的情况下，用户在一处等候，就不用再其他系统中登录。

最简单的就是用Cookie，不安全，不能跨域免登。

在服务端存储信任关系。

SSO认证中心。


# SQL问题
写sql

## sql1
表test：

|id|a|b|
|---|---|---|
|1|4|2|
|2|1|2|
|3|1|3|
|4|3|2|
|5|1|5|
|6|1|2|
|7|4|-1|
|8|1|2|
|9|3|1|
|10|4|2|

写一条sql，选择所有a=1或者b=2的记录，使得a=1且b=2的记录排在最前面，并且a=1且a=2的记录按照id降序排列。

a=1或b=2包括了a=1且b=2，可分成两部分，第一部分查找a=1且b=2的数据，第二部分查找a=1且b!=2和a!=1且b=2的数据，联合。

```
select T.* from (select * from test where (a = 1 and b = 2) order by id desc) T
union 
select * from test where (a=1 and b<>2) or (a<>1 and b=2);
```

union 的各个子查询需要有相同的数量的列，且对应位置的列必须具有相同类型的数据类型，但列的名字可以不同。

只能在union最后一个子查询中使用order by，这个order by是针对整个union之后的结果集的。

## 什么是存储过程，用什么来调用
存储过程是一个预编译的sql语句，优点是允许模块化的设计，就是说只需要创建一次，以后再该程序中就可以多次调用，如果说某次操作需要执行多次sql，使用存储过程比单纯sql语句要快。可用命令对象来调用存储过程。

## 触发器的作用
触发器是一种特殊的存储过程，主要通过事件来触发而被执行的，可以强化约束，来维护数据的完整性和一致性。


