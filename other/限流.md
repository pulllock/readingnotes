# 限流维度

- 并发数：限制同一时刻最大并发请求数
- QPS：限制一段时间内请求数

# 限流算法

1. 固定窗口计数
2. 滑动窗口计数
3. 滑动窗口日志
4. 令牌桶
5. 漏桶

固定窗口计数、滑动窗口计数、滑动窗口日志这三种限流算法，一旦窗口流量达到阈值，超出阈值的流量会被马上丢弃掉。而令牌桶和漏桶算法不会立刻就丢弃掉流量，可以让流量平稳的过度。

## 固定窗口计数

固定窗口计数算法是在一个固定的周期内使用计数器来累加访问次数，在当前周期内如果计数达到了设置的阈值，则超过阈值的流量会被抛弃掉；下一个周期开始的时候计数器清零并重新开始计数。

固定窗口计数算法通常用于QPS限流，优点是简单；缺点是会存在临界问题，即在两个周期相邻的位置可能会出现超过阈值的问题，虽然在两个周期各自的周期范围内没有超过阈值，但是在临界的周围时间范围内实际已经超过了阈值。

## 滑动窗口计数

滑动窗口计数算法是将时间周期分为N个小周期，分别记录每个小周期内的访问次数，并且根据时间进行周期滑动，将过期的周期的计数删除，按照滑动后的新的周期进行计数。

滑动窗口计数算法可以解决固定窗口计数算法的临界问题，滑动窗口的小周期划分的越多，滑动窗口滚动越平滑，计数就会越精确。

## 滑动窗口日志

滑动窗口日志算法会记录下所有请求的时间点和同一时间点的计数统计，在新请求到来时会先判断在最近的周期范围内请求数量是否超过指定的阈值，如果超过了阈值则丢弃掉流量。

滑动窗口日志限流比较准确，但是需要每次记录请求的时间点以及技术，内存占用比较多。在高并发情况下对删除的性能要求较高。

## 令牌桶

令牌桶算法是以固定的速度（固定速度=时间周期/限流阈值）向令牌桶中添加令牌直到令牌桶满，当请求到达时会从令牌桶中拿令牌，如果获取到了令牌则可以执行请求，如果获取不到令牌就抛弃请求。

令牌桶算法能够限制请求的平均处理速度，还允许突发流量。

## 漏桶

漏桶算法是请求到达时直接放置到漏桶中，如果已经到达阈值则抛弃请求，漏桶以固定的速率进行请求的释放，直到漏桶为空。

漏桶算法的请求处理是匀速的，能够强行限制请求处理的速度，不允许突发流量。

# 限流场景

- 单机限流：对每台实例进行限流，可以防止突发流量压垮服务器，比较适合对并发做限制
- 分布式限流：对服务集群进行限流，适合做更细粒度的限流，防止服务资源被过度使用

## 单机限流实现

- 固定窗口计数
- 滑动窗口计数
- 滑动日志计数
- 令牌桶
- 漏桶
- 信号量计数
- 线程池隔离

## 分布式限流实现

- 固定窗口计数，Redis+Lua

# 其他的限流手段

- 信号量计数，常用来控制并发，简单高效，但是只能在单机使用
- 线程池隔离，通过线程数来对流量进行限制，需要考虑线程切换的成本，只能在单机中使用

# 限流工具

- Guava的RateLimiter，令牌桶算法
- Bucket4j，令牌桶算法
- Hystrix
- Resilience4j
- Sentinel
- concurrency-limits