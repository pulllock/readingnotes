在[JVM运行时数据区域介绍](http://cxis.me/2017/05/06/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E4%BB%8B%E7%BB%8D/)里面介绍了有关Java虚拟机规范中规定的运行时区域划分，对于更具体的划分，虚拟机规范并没有说明，通常由各个虚拟机厂商自己实现。这里就以我最长接触的Oracle的Hotspot虚拟机来进行说明。（关于各个厂商虚拟机和具体的实现还请自行研究）。

Java虚拟机规范中规定运行时数据区域包括：程序计数器，Java虚拟机栈，堆，方法区，本地方法栈。其中Java虚拟机栈中包含栈帧，栈帧用来存储局部变量表、操作数栈、指向当前方法所属类的运行时常量池的引用等；方法区用于存储已加载的类的信息，其中包含运行时常量池、字段、方法数据、构造函数、普通方法的字节码等内容。而对于堆并没有做具体的分类，堆的具体划分是由虚拟机实现厂商来规定，没有统一的规范。

下面的内容都以最常用的Hotspot虚拟机来进行讲述。

# 堆内存分配
关于堆中内存区域的划分，并不是为了划分而划分，而是为了更好的进行垃圾回收而划分，有关JVM垃圾回收的历史、相关策略、相关算法这里不做解析，这里关注下最常区分的区域问题。

根据对象存活的时间不同，JVM对于GC策略采用分代垃圾回收，这就需要把堆内存划分为不同的区域进行管理。堆内存通常分为新生代和老年代两个区域，新生代分为一个Eden区域和两个Survivor区域。

之所以会这样分代，是因为有做过统计，绝大部分的对象都很短命。这样分代之后，可以对不同的代选择不同的垃圾回收算法，而如果我们的程序中对象不是这样的，那么这种分代收集效率就一定会很低，不过一般不会遇到这样的。

新生代（Young Generation）分为Eden区域、From Survivor和To Survivor三个区域。

对象的内存分配优先在Eden区上，少数情况下会直接分配到老年代上。一个Eden区域和一个Survivor的比例是8:1。Survivor区域用于存放每次垃圾回收之后存活的对象。

老年代主要用来存放大对象和长期存活的对象。


# 永久代
在Hotspot虚拟机中永久代就是方法区。而在Java8之后，永久代被移除，被Metaspace所取代。

在新生代发生的垃圾回收叫Minor GC，当新生代区域满了之后，会触发GC，只对新生代进行回收。

在老年代发生的垃圾回收叫Full GC或者Major GC，当老年代区域满了之后，会触发GC，Full GC会对新生代，老年代和永久代进行回收。
