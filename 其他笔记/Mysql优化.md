# 数据库的设计
尽量把数据库设计的更小的占磁盘空间

尽可能使用更小的整数类型.(mediumint就比int更合适).

尽可能的定义字段为not null,除非这个字段需要null.

如果没有用到变长字段的话比如varchar,那就采用固定大小的纪录格式比如char.

表的主索引应该尽可能的短.这样的话每条纪录都有名字标志且更高效.

只创建确实需要的索引。索引有利于检索记录，但是不利于快速保存记录。

如果总是要在表的组合字段上做搜索，那么就在这些字段上创建索引。

索引的第一部分必须是最常使用的字段.如果总是需要用到很多字段，首先就应该多复制这些字段，使索引更好的压缩。

所有数据都得在保存到数据库前进行处理。

所有字段都得有默认值。

在某些情况下,把一个频繁扫描的表分成两个速度会快好多。

在对动态格式表扫描以取得相关记录时，它可能使用更小的静态格式表的情况下更是如此。

# 索引优化
普通索引，唯一索引，联合索引

# sql语句优化
查询不用*号，不用子查询，少用带%的like语句

尽量使用长连接.

explain 复杂的SQL语句。

如果两个关联表要做比较话，做比较的字段必须类型和长度都一致.

LIMIT语句尽量要跟order by或者 distinct.这样可以避免做一次full table scan.

如果想要清空表的所有纪录,建议用truncate table tablename而不是delete from tablename

能使用STORE PROCEDURE 或者 USER FUNCTION的时候.

在一条insert语句中采用多重纪录插入格式.而且使用load data infile来导入大量数据，这比单纯的indert快好多.

经常OPTIMIZE TABLE 来整理碎片.

说明:http://blog.sina.com.cn/s/blog_3dbab2840100c13p.html

还有就是date 类型的数据如果频繁要做比较的话尽量保存在unsigned int 类型比较快。



# 缓存优化
避免每次请求都需要查询数据库，尽量在有查询的地方用缓存，最简单的就是部署memcached做被动缓存。对查询出来的数据作一定时间的缓存，对于实时性要求比较高的功能，可做主动缓存，数据更新立马更新缓存。

# 读写分离
读写分离，主从数据库
# 分库分表

# 存储引擎

# mysql参数调优

