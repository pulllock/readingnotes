# 数据结构绪论

## 逻辑结构
是指数据对象中数据元素之间的相互关系.

1. 集合结构:集合结构中的数据元素除了属于同一集合外,他们之间没有其他关系.
2. 线性结构:线性结构中的数据元素之间是一对一的关系.
3. 树形结构:树形结构中的数据元素之间存在一对多的层次关系.
4. 图形结构:图形结构的数据是多对多的关系. 

## 物理结构
是指数据的逻辑结构在计算机中的存储形式.

1. 顺序存储结构:把数据元素存放在地址连续的存储单元里,其数据间的逻辑关系和物理关系是一致的.
2. 链式存储结构:把数据元素放在任意的存储单元里,这组存储单元可以使连续的,也可以是不连续的.

# 算法

## 算法特性

1. 输入
2. 输出
3. 有穷性
4. 确定性
5. 可行性

## 算法时间复杂度

### 推导大O阶方法
	1. 用常数1取代运行时间中的所有加法常数
	2. 在修改后的运行次数函数中,只保留最高阶项
	3. 如果最高阶项存在并且不是1,则去除与这个项相乘的常数.得到的结果就是大O阶

# 线性表

## 线性表的抽象数据类型

```
ADT 线性表(List)
Data
	线性表的数据对象集合为{a1,a2,......,an},每个元素的类型均为DataType.其中,除第一个元素a1外,每个元素有且只有一个直接前驱元素,除了最后一个元素an外,每一个元素有且只有一个直接后继元素.数据元素之间的关系是一对一的关系.
Operation
	InitList(*L):初始化操作,建立一个空的线性表L.
	ListEmpty(L):线性表为空返回true,否则返回false.
	ClearList(*L):将线性表清空.
	GetElem(L,i,*e):将线性表L中第i个位置元素值返回给e.
	LocateElem(L,e):在线性表L中查找与给定值e相等的元素,成功返回该元素在表中序号,否则返回0表示失败.
	ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e.
	ListDelete(*L,i,*e):删除线性表L中第i个位置元素,并且用e返回其值.
	ListLength(L):返回线性表L的元素个数
endADT
```
## 线性表的顺序存储结构

### 优点
* 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
* 可以快速地存取表中任一位置的元素

### 缺点
* 插入和删除操作需要移动大量元素
* 当线性表长度变化较大时,难以确定存储空间的容量
* 造成存储空间的碎片

## 线性表的链式存储结构

## 单链表结构与顺序存储结构优缺点
### 存储分配方式
* 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素
* 单链表采用链式存储结构,用一组任意的存储单元存放线性表的元素

### 时间性能
* 查找
	- 顺序存储结构(X1)
	- 单链表(Xn)
* 插入和删除
	- 顺序存储结构需要平均移动表长一半的元素,时间为O(n)
	- 单链表在找出某位置的指针后,插入和删除时时间仅为O(1)
* 空间性能
	- 顺序存储结构需要预分配存储空间,分大了,浪费,分小了易发生上溢
	- 单链表不需要分配存储空间,只要有就可以分配,元素个数也不受限制

## 静态链表

## 循环链表

## 双向链表

插入：


```
s->pre = p;
s->next = p->next
p->next->pre = s
p->next = s
```
记忆：先搞定s的前驱和后继，再搞定后面结点的前驱，最后搞定前面结点的后继。

# 栈与队列

## 栈
是限定仅在表尾进行插入和删除操作的线性表
## 栈的顺序存储结构

## 栈的链式存储结构

## 中缀表达式
## 后缀表达式
中缀表达式转后缀表达式规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号，则栈顶元素依次出栈并输出，并将符号进栈，一直到最后输出后缀表达式为止。
## 后缀表达式计算
规则：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号，就将栈顶两个数字出栈，进行运算，并将结果进栈，直到最后获得结果。
## 队列

## 循环队列
队列满的条件是 `(tail + 1) % QueueSize == head`

计算队列长度通用公式：`(tail - head + QueueSize) % QueueSize`
# 串


# 树

## 二叉树

### 二叉树的顺序存储结构
一般只用于完全二叉树

### 二叉链表
二叉链表节点结构定义:

```
typedef struct BiTNode /*结点结构*/
{
	TElemType data;/*结点数据*/
	struct BiTNode *lchild, *rchild;/*左右结点*/
} BiTNode,*BiTree;
```

### 二叉树遍历方法
1. 前序遍历
	
	先访问根结点,然后前序遍历左子树,再前序遍历右子树
	
	```
	void PreOrderTraverse(BiTree T)
	{
		if(T == NULL)
			return;
		printf("%c",T->data);/*显示结点数据*/
		PreOrderTraverse(T->lchild);/*先序遍历左子树*/
		PreOrderTraverse(T->rchild);/*先序遍历右子树*/
	}
	```
2. 中序遍历
	
	从根结点开始,中序遍历根结点的左子树,然后访问根结点,最后中序遍历右子树
	
	```
	void InOrderTraverse(BiTree T)
	{
		if(T == NULL)
			return;
		InOrderTraverse(T->lchild);/*中序遍历左子树*/
		printf("%c",T->data);/*显示结点数据*/
		InOrderTraverse(T->rchild);/*中序遍历右子树*/
	}
	```
3. 后序遍历
	
	从左到右先叶子后结点的方式遍历访问左右子树,最后访问根结点
	
	```
	void PostOrderTraverse(BiTree T)
	{
		if(T == NULL)
			return;
		PostOrderTraverse(T->lchild);/*后序遍历左子树*/
		PostOrderTraverse(T->rchild);/*后序遍历右子树*/
		printf("%c",T->data);/*显示结点数据*/
	}
	```
	
4. 层序遍历
	
	从树的第一层,根结点开始访问,从上而下逐层遍历,在同一层中,按从左到右的顺序对结点逐个访问


### 线索二叉树

# 查找
## 顺序查找
顺序查找，又叫线性查找，从表中第一个或最后一个记录开始，逐个进行记录的查找。

## 线性索引查找
### 稠密索引
稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。

### 分块索引

### 倒排索引

## 二叉排序树
二叉排序树（Binary Sort Tree）又称二叉查找树，若左子树不为空，则左子树上的所有结点的值都小于她的根结点的值，若右子树不为空，则右子树上所有结点的值均大于根结点的值，左右子树也分别为二叉排序树。

二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点。

## 平衡二叉树
平衡二叉树，是一种二叉查找树，其中每一个结点的左子树和右子树的高度差至多等于1。

最小不平衡子树，距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树

## 多路查找树
多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。
