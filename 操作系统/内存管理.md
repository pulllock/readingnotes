# 内存管理

内存管理

# 地址空间

地址空间是一个进程可用于寻址内存的一套地址集合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享他们的地址空间外）

## 基址寄存器与界限寄存器

当使用基址寄存器和界限寄存器时，程序装载到内存中连续的空闲位置并且装载期间无需重定位，当一个进程运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。每次一个进程访问内存，取一条指令，读或写一个数据字，CPU硬件会在把地址发送到内存总线前，自动把基址值加到进程发出的地址值上，同时它检查程序提供的地址是否等于或大于界限寄存器里的值，如果访问的地址超过了界限，会产生错误并终止访问。

使用基址寄存器和界限寄存器重定位的缺点是，每次访问内存都需要进行加法和比较运算，比较运算可以作的很快，但是加法运算由于进位传递时间的问题，在没有使用特殊电路的情况下会显得很慢。

## 交换技术

交换（swapping），把一个进程完整调入内存，使该进程运行一段时间，然后把他存回磁盘，空闲进程主要存储在磁盘上，所以当他们不运行时就不会占用内存。

交换在内存中产生很多空闲区（hole，也称空洞），通过把所有进程尽可能向下移动，有可能将这些小的空闲区合成一大块，该技术称为内存紧缩（memory compaction），通常不进行这个操作，因为会耗费大量的CPU时间。

## 空闲内存管理

有两种方法跟踪内存使用情况：

- 位图
- 空闲区链表

### 位图

使用位图方法时，内存可能会被划分为不同大小的分配单元，每个分配单元对应于位图中的一位，0表示空闲，1表示占用。分配单元越小，位图越大。位图提供了一种简单的利用一块固定大小的内存区就能对内存使用情况进行记录的方法。缺点是需要搜索位图来找到可用内存，在位图中查找指定长度的连续的空闲的位是耗时的操作。

### 空闲区链表

维护一个记录已分配内存段和空闲内存段的链表，链表中的一个节点即可以存一个进程，也可以存两个进程间的一块空闲区。

当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程来分配内存：

- 首次适配算法（first fit）：存储管理器沿着链表进行搜索，找到一个足够大的空闲区，除非空闲区大小和要分配的空间大小正好一样，否则将该空闲空间分为两部分，一部分供进程使用，另一部分形成新的空闲区。首次适配算法速度快，因为它尽可能少的搜索链表节点
- 下次适配算法（next fit）：查找方式和首次适配算法一样，不同的是每次找到合适的空闲区都记录下来位置，下次再寻找空闲区时直接从上次结束的地方开始搜索，而不是像首次适配算法那样每次都从头开始。下次适配算法的性能略低于首次适配算法
- 最佳适配（best fit）：搜索整个链表，找出能容纳进程的最小的空闲区，最佳适配算法视图找出最接近实际需要的空闲区，以最好的匹配请求和可用空闲区。最佳适配算法每次都搜索整个链表，它会比首次适配算法慢，它还会浪费更多的内存，因为它会产生大量无用的小空闲区
- 最差适配（worst fit）：总是分配最大的可用空闲区，使新的空闲区比较大从而可以继续使用
- 快速适配算法（quick fit）：为那些常用大小的空闲区维护单独的链表，快速适配算法寻找一个指定大小的空闲区是时分快速的，缺点是在一个进程终止或被换出时，寻找它的相邻块并查看是否可以合并的过程非常耗时，如果不进行合并则内存将会很快被分裂出大量的小空闲区

# 虚拟内存

虚拟内存（virtual memory），可以使程序在只有一部分被调入内存的情况下运行。每个空虚拥有自己的地址空间，这个空间被分成多块，每一块称作一页或页面（page），每一页有连续的 地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件立刻执行必要的映射。当引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。

## 分页

分页（paging）

由程序产生的地址称为虚拟地址（virtual address），它们构成了一个虚拟地址空间（virtual address space），在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字；在有虚拟内存的系统上，虚拟地址被送到内存管理单元（Memory Management Unit，MMU）MMU把虚拟地址映射为物理地址。

虚拟地址空间按照固定大小划分为若干单元，称为页面（page），在物理内存中对应的单元称为页框（page frame），页面和页框的大小通常是一样的。

MMU如果发现页面没有被映射，使CPU陷入到操作系统，这个陷阱称为缺页中断或缺页错误（page fault），操作系统找到一个很少使用的页框并把它的内容写入到磁盘，随后把需要访问的页读到刚才回收的页框中，修改映射关系，然后重新启动引起陷阱的指令。

## 页表

页表（page table）的目的是把虚拟页面映射为页框，页表项结构：

```
------------------------------------------------------------------------
|    | 高速缓存禁止位 | 访问位 | 修改位 | 保护位 | 在/不在位 |      页框号     |
------------------------------------------------------------------------
```

- 页框号

- 在/不在位，1表示该表项是有效的，可以使用；0表示该表项对应的虚拟页面现在不在内存中，访问该页面会引起一个缺页中断

- 保护（protection）位，指出一个页允许什么类型的范围，最简单的形式是这个域只有一位，0表示读/写，1表示只读；更先进的方法是使用三位，各位分别对应：是否启用读、写、执行该页面

- 修改（modified）位，在写入一页时由硬件自动设置修改位，该位在操作系统重新分配页框时有用，如果一个页面已经被修改过，则必须把它写回磁盘，如果一个页面没有被修改过，则直接简单的丢弃就可以。该位有时也称为脏位（dirty bit）

- 访问（referenced）位，无论是读还是写，系统都会在该页面被访问时设置访问位，该值用来帮助操作系统在发生缺页中断时选择要被淘汰的页面

- 高速缓存禁止位，用于禁止该页面被高速缓存

## 加速分页过程

### 转换检测缓冲区

为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必访问页表，这种设备称为转换检测缓冲区（Translation Lookaside Buffer，TLB）又称相联存储器（associate memory）或快表。

通常位于MMU中，只包含少量表项，每个表项记录了一个页面的信息，包括：虚拟页号、页面的修改位、保护码（读/写/执行权限）、页框号、有效位

### 软件TLB管理

### 针对大内存的页表

- 多级页表

- 倒排页表

# 页面置换算法

## 最优页面置换算法

在缺页中断发生时，有些页面在内存中，其中有一个页面将很快被访问，其他页面则可能要到N条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数作为标记，最优页面置换算法规定应置换标记最大的页面。

最优页面置换算法是无法实现的。

## 最近未使用页面置换算法

NRU（Not Recently Used，最近未使用）

## 先进先出页面置换算法

FIFO（First-In First-Out，先进先出）

FIFO算法可能会把经常使用的页面置换出去。

## 第二次机会页面置换算法

FIFO算法可能会把经常使用的页面置换出去，可对FIFO算法做一个修改：检查最老页面的R位，如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，则将R位清0，并把该页面放到链表尾端，修改它的装入时间是它就像刚装入一样，然后继续搜索，这种算法称为第二次机会（second chance）算法

第二次机会算法是寻找一个最近的时钟间隔内没有被访问过的页面，如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。

第二次机会算法需要经常在链表中移动页面，会降低效率。

## 时钟页面置换算法

把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面，当发生缺页中断时，首先检查表针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；如果R位是1就清除R位并把表针前移一个位置，重复这个过程直到找到了一个R位为0的页面为止。

## 最近最少使用页面置换算法

Least Recently Used（LRU，最近最少使用）

在缺页中断发生时，置换未使用时间最长的页面。

LRU实现代价很高，需要在内存中维护一个所有页面的链表，最近最多使用的在表头，最近最少使用的在表尾，在每次访问内存时都必须要更新整个链表，在链表中找到一个页面删除，然后把它移到表头是一个非常耗时的操作。

## 工作集页面置换算法

一个进程当前正在使用的页面的集合称为它的工作集。

分页系统会设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已在内存中，该方法称为工作集模型。在进程运行前预先装入其工作集页面也称为预先调页。

## 工作集时钟页面置换算法

基本的工作集页面置换算法在缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，是比较耗时的，有一种改进的基于时钟的算法，称为工作集时钟算法（WSClock）。