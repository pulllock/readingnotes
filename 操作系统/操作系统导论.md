# 第1章 关于本书的对话

三个关键概念：

- virtualization（虚拟化）
- concurrency（并发）
- persistence（持久性）

# 第2章 操作系统介绍

推荐书籍：

- 《Introduction to Computing Systems: From Bits and Gates to C and Beyond》Yale N. Patt and Sanjay J. Patel McGraw-Hill, 2003

- 《Computer Systems: A Programmer’s Perspective》 Randal E. Bryant and David R. O’Hallaron
  Addison-Wesley, 2010

程序运行时会发生什么？执行指令

处理器从内存中获取（fetch）一条指令，对其进行解码（decode）（弄清楚这是哪条指令），然后执行（execute）它（做它应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等）。完成这条指令后，处理器继续执行下一条指令，依此类推，直到程序最终完成。

如何将资源虚拟化

操作系统主要利用虚拟化（virtualization）技术，将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。有时将操作系统称为虚拟机（virtual machine）。

操作系统还提供了一些接口（API）、系统调用（system call）。由于操作系统提供这些调用来运行程序、访问内存和设备，并进行其他相关操作，有时也会说操作系统为应用程序提供了一个标准库（standard library）。

虚拟化让许多程序运行（从而共享CPU），让许多程序可以同时访问自己的指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘等），所以操作系统有时被称为资源管理器（resource manager）。

# 第4章 抽象：进程

## 4.1 抽象：进程

操作系统为正在运行的程序提供的抽象，就是进程（process）。

## 4.4 进程状态

- 运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。

- 就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。

- 阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。

# 第5章 插叙：进程API

- fork()

- exec()

- wait()

# 第6章 机制：受限直接执行

## 6.3 问题2：在进程之间切换

- 时钟中断（timer interrupt）

- 上下文切换（context switch）

# 第7章 进程调度：介绍

## 7.3 先进先出（FIFO）

先进先出（First In First Out或FIFO），也称先到先服务（First Come First Served或FCFS）

## 7.4 最短任务优先（SJF）

最短任务优先（Shortest Job First，SJF）

## 7.5 最短完成时间优先（STCF）

最短完成时间优先（Shortest Time-to-Completion First，STCF）或抢占式最短作业优先（Preemptive Shortest Job First，PSJF）

## 7.7 轮转

轮转（Round-Robin，RR）。基本思想：RR在一个时间片（time slice）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。时间片长度必须是时钟中断周期的倍数。

# 第8章 调度：多级反馈队列

多级反馈队列（Multi-level Feedback Queue，MLFQ）

## 8.1 MLFQ：基本规则

MLFQ中有许多独立的队列，每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ总是优先执行较高优先级的工作。

每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。

MLFQ两条基本规则：

- 规则1：如果A的优先级大于B的优先级，运行A。

- 规则2：如果A的优先级等于B的优先级，轮转运行A和B。

## 8.2 尝试1：如何改变优先级

- 规则3：工作进入系统时，放在最高优先级。

- 规则4a：工作用完整个时间片后，降低其优先级。

- 规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变。

## 8.3 尝试2：提升优先级

-  规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。

## 8.4 尝试3：更好的计时方式

- 规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级。

# 第9章 调度：比例份额

比例份额（proportional-share），有时也称为公平份额（fair-share）。比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。

彩票调度（lottery scheduling），基本思想：每个一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个进程。

## 9.1 基本概念：彩票数表示份额

彩票数（ticket）代表了进程占有某个资源的份额。一个进程拥有彩票数占总彩票数的百分比，就是它占有资源的份额。

# 第10章 多处理器调度（高级）

## 10.1 背景：多处理器架构

缓存是基于局部性（locality）的概念，局部性有两种，即时间局部性和空间局部性。时间局部性是指当一个数据被访问后，它很有可能会在不久的将来被再次访问。而空间局部性指的是，当程序访问地址为x的数据时，很有可能会紧接着访问x周围的数据。

## 10.4 单队列调度

单队列多处理器调度（Single Queue Multiprocessor Scheduling，SQMS）。

缺点：

- 缺乏可扩展性（scalability）为了保证在多CPU上正常运行，调度程序的开发者需要在代码中通过加锁来保证原子性。锁可能带来巨大的性能损失。

- 第二个问题是不能很好的保证缓存亲和性

## 10.5 多队列调度

多队列多处理器调度（Multi-Queue Multiprocessor Scheduling，MQMS）。基本调度框架包含多个调度队列，每个队列可以使用不同的调度规则。

MQMS比SQMS有明显优势，它天生更具有扩展性。队列的数量会随着CPU的增加而增加，因此锁和缓存争用的开销不是大问题。MQMS天生具有良好的缓存亲和度。所有工作都保持在固定的CPU上，因而可以很好地利用缓存数据。

缺点：负载不均衡。

让工作移动，这种技术称为迁移（migration）。通过工作的跨CPU迁移，可以真正实现负载均衡。



工作窃取（work stealing）