# 第1章 基础：逻辑和证明

## 1.1 命题逻辑

### 1.1.1 引言

### 1.1.2 命题

逻辑的基本构件：命题。

命题：是一个陈述语句，它或真或假，但不能既真又假。

用字母来表示命题变量（或称为语句变量），即表示命题的变量。习惯上用字母p、q、r、s等表示命题变量。

如果一个命题是真命题，则它的真值为真，用T表示；如果它是假命题，则其真值为假，用F表示。

不能用简单的命题来表示的命题称为原子命题。

涉及命题的逻辑领域称为命题演算或命题逻辑。

由已知命题用逻辑运算符组合而来的新命题被称为复合命题。

定义1：

令p为一命题，则p的否定记作 $\lnot p$（也可记作 $\overline p$），指“不是p所指的情形”。命题 $\lnot p$读作“非p”。p的否定（ $\lnot p$）的真值和p的真值相反。

命题之否定的真值表：

| p   | $\lnot p$ |
| --- | --------- |
| T   | F         |
| F   | T         |

从两个或多个已知命题构造新命题的逻辑运算符，称为联结词。

定义2：

令p和q为命题。p、q的合取即命题“p并且q”，记作 $p \land q$。当p和q都是真时， $p \land q$命题为真，否则为假。

在逻辑中，有时候会用“但是”一次替代“并且”一词来表示合取。

两个命题合取的真值表：

| p   | q   | $p \land q$ |
| --- | --- | ----------- |
| T   | T   | T           |
| T   | F   | F           |
| F   | T   | F           |
| F   | F   | F           |

定义3：

令p和q为命题。p和q的析取即命题“p或q”，记作 $p \lor q$。当p和q均为假时，析取命题 $p \lor q$为假，否则为真。

在析取中使用的联结词或（or）对应于在自然语言中使用或字的两种情况之一，即：兼或（inclusive or）。析取为真，只要两个命题之一为真或者两者均为真即可。

两个命题析取的真值表：

| p   | q   | $p \lor q$ |
| --- | --- | ---------- |
| T   | T   | T          |
| T   | F   | T          |
| F   | T   | T          |
| F   | F   | F          |

或联结词除了用于表示析取，也可以用来标识异或。当恰好p和q之一为真时，这两个命题的异或为真；而当p和q两者均为真（或均为假）时，它就为假。

定义4：

令p和q为命题。p和q的异或（记作 $p \oplus q$）是这样一个命题：当p和q中恰好只有一个为真时命题为真，否则为假。

两个命题异或的真值表：

| p   | q   | $p \oplus q$ |
| --- | --- | ------------ |
| T   | T   | F            |
| T   | F   | T            |
| F   | T   | T            |
| F   | F   | F            |

### 1.1.3 条件语句

定义5：

令p和q为命题。条件语句 $p \to q$是命题“如果p，则q”。当p为真而q为假时，条件语句 $p \to q$为假，否则为真。在条件语句 $p \to q$中，p称为假设（前件、前提），q称为结论（后件）。

语句 $p \to q$称为条件语句，因为 $p \to q$可以断定在条件p成立的时候q为真。条件语句也称为蕴含。

条件语句 $p \to q$的真值表：

| p   | q   | $p \to q$ |
| --- | --- | --------- |
| T   | T   | T         |
| T   | F   | F         |
| F   | T   | T         |
| F   | F   | T         |

常用的条件语句的表示方式：

- 如果p，则q

- 如果p，q

- p是q的充分条件

- q如果p

- q当p

- p的必要条件是q

- q除非 $\lnot p$

- p蕴含q

- p仅当q

- q的充分条件是p

- q每当p

- q是p的必要条件

- q由p得出

- q假定p

在数学推理中，我们考虑的条件语句比语言中使用的要广泛一些。条件语句作为一个数学概念不依赖于假设和结论之间的因果关系。我们关于条件语句的定义规定了它的真值，而这一定义不是以语言的用法为基础的。

#### 逆命题、逆否命题与反命题

命题 $q \to p$称为 $p \to q$的逆命题，而 $p \to q$的逆否命题是 $\lnot q \to \lnot p$。命题 $\lnot p \to \lnot q$称为 $p \to q$的反命题。

当两个复合命题总是具有相同真值时，无论其命题变量的真值是什么，称它们是等价的。因此一个条件语句与它的逆否命题是等价的。条件语句的逆与反也是等价的。

#### 双条件语句

定义6：

令p和q为命题。双条件语句 $p \leftrightarrow q$是命题“p当且仅当q”。当p和q有同样的真值时，双条件语句为真，否则为假。双条件语句也成为双向蕴含。

常用方式：

- p是q的充分必要条件

- 如果p那么q，反之亦然

- p当且仅当q

- p恰好当q

双条件语句 $p \leftrightarrow q$的真值表：

| p   | q   | $p \leftrightarrow q$ |
| --- | --- | --------------------- |
| T   | T   | T                     |
| T   | F   | F                     |
| F   | T   | F                     |
| F   | F   | T                     |

### 1.1.4 复合命题的真值表

可以用真值表来决定这些复合命题的真值。

### 1.1.5 逻辑运算符的优先级

| 运算符               | 优先级 |
| ----------------- | --- |
| $\lnot$           | 1   |
| $\land$           | 2   |
| $\lor$            | 3   |
| $\to$             | 4   |
| $\leftrightarrow$ | 5   |

### 1.1.6 逻辑运算和比特运算

比特是一个具有两个可能值的符号，即0和1。

用1表示真（T），0表示假（F）。如果一个变量的值为真或为假，此变量就称为布尔变量。一个布尔变量可以用一比特表示。

计算机的比特运算（或位运算）对应于逻辑联结词。

位运算符OR、AND、XOR的真值表：

| x   | y   | $x \lor y$ | $x \land y$ | $x \oplus y$ |
| --- | --- | ---------- | ----------- | ------------ |
| 0   | 0   | 0          | 0           | 0            |
| 0   | 1   | 1          | 0           | 1            |
| 1   | 0   | 1          | 0           | 1            |
| 1   | 1   | 1          | 1           | 0            |

定义7：

比特串是0比特或多比特的序列。比特串的长度就是它所含比特的数目。

## 1.2 命题逻辑的应用

### 1.2.1 语句翻译

各种人类语言常有二义性，把语句翻译成复合命题可以消除歧义。

用命题变量表示语句中的每个成分，并找出它们之间合适的逻辑联结词。

### 1.2.3 系统规范说明

系统规范说明应该是一致的，也就是说，系统规范说明不应该包含可能导致矛盾的相互冲突的需求。

### 1.2.4 布尔搜索

逻辑联结词广泛用于海量信息如网页索引的搜索中。由于搜索采用命题逻辑的技术，所以被称为布尔搜索。

- AND用于匹配同时包含两个搜索项的记录
- OR用于匹配两个搜索项之一或两项均匹配的记录
- NOT（有时写作AND NOT）用于排除某个特定的搜索项。

### 1.2.5 逻辑谜题

可以用逻辑推理解决的谜题称为逻辑谜题。

### 1.2.6 逻辑电路

逻辑电路（或数字电路）接受输入信号 $p_1, p_2, ..., p_n$，每个信号1比特，产生输出信号 $s_1, s_2, ..., s_n$，每个1比特。

门电路：

- 逆变器或非门（NOT gate）接受一个输入比特p，产生 $\lnot p$作为输出。
- 或门（OR gate）接受两个输入信号p和q，每个1比特，产生信号 $p \lor q$作为输出
- 与门（AND gate）接受两个输入信号p和q，每个1比特，产生信号 $p \land q$作为输出。

## 1.3 命题等价式

### 1.3.1 引言

定义1：

一个真值永远是真的复合命题（无论其中出现的命题变量的真值是什么），称为永真式（tautology），也称为重言式。一个真值永远为假的复合命题称为矛盾式（contradiction）。既不是永真式又不是矛盾式的复合命题称为可能式（contingency）。

### 1.3.2 逻辑等价式

在所有可能的情况下都具有相同真值的两个复合命题称为逻辑等价的。

定义2：

如果 $p \leftrightarrow q$是永真式，则复合命题p和q称为是逻辑等价的。用记号 $p \equiv q$表示p和q是逻辑等价的。

德·摩根律：

| 等价式                                             |
| ----------------------------------------------- |
| $\lnot (p \land q) \equiv \lnot p \lor \lnot q$ |
| $\lnot (p \lor q) \equiv \lnot p \land \lnot q$ |

逻辑等价式：

| 等价式                                                      | 名称    |
| -------------------------------------------------------- | ----- |
| $p \land T \equiv p$                                     | 恒等律   |
| $p \lor F \equiv p$                                      | 恒等律   |
| $p \lor T \equiv T$                                      | 支配律   |
| $p \land F \equiv F$                                     | 支配律   |
| $p \lor p \equiv p$                                      | 幂等律   |
| $p \land p \equiv p$                                     | 幂等律   |
| $\lnot (\lnot p) \equiv p$                               | 双重否定律 |
| $p \lor q \equiv q \lor p$                               | 交换律   |
| $p \land q \equiv q \land p$                             | 交换律   |
| $(p \lor q) \lor r \equiv p \lor (q \lor r)$             | 结合律   |
| $(p \land q) \land r \equiv p \land (q \land r)$         | 结合律   |
| $p \lor (q \land r) \equiv (p \lor q) \land (p \lor r)$  | 分配律   |
| $p \land (q \lor r) \equiv (p \land q) \lor (p \land r)$ | 分配律   |
| $\lnot (p \land q) \equiv \lnot p \lor \lnot q$          | 德·摩根律 |
| $\lnot (p \lor q) \equiv \lnot p \land \lnot q$          | 德·摩根律 |
| $p \lor (p \land q) \equiv p$                            | 吸收律   |
| $p \land (p \lor q) \equiv p$                            | 吸收律   |
| $p \lor \lnot p \equiv T$                                | 否定律   |
| $p \land \lnot p \equiv F$                               | 否定律   |

条件命题的逻辑等价式：

| 等价式                                                  |
| ---------------------------------------------------- |
| $p \to q \equiv \lnot p \lor q$                      |
| $p \to q \equiv \lnot q \to \lnot p$                 |
| $p \lor q \equiv \lnot p \to q$                      |
| $p \land q \equiv \lnot (p \to \lnot q)$             |
| $\lnot (p \to q) \equiv p \land \lnot q$             |
| $(p \to q) \land (p \to r) \equiv p \to (q \land r)$ |
| $(p \to r) \land (q \to r) \equiv (p \lor q) \to r$  |
| $(p \to q) \lor (p \to r) \equiv p \to (q \lor r)$   |
| $(p \to r) \lor (q \to r) \equiv (p \land q) \to r$  |

双条件命题的逻辑等价式：

| 等价式                                                                   |
| --------------------------------------------------------------------- |
| $p \leftrightarrow q \equiv (p \to q) \land (q \to p)$                |
| $p \leftrightarrow q \equiv \lnot p \leftrightarrow \lnot q$          |
| $p \leftrightarrow q \equiv (p \land q) \lor (\lnot p \land \lnot q)$ |
| $\lnot (p \leftrightarrow q) \equiv p \leftrightarrow \lnot q$        |

德·摩根律可以扩展为：

$$
\lnot (p_1 \lor p_2 \lor ... \lor p_n) \equiv (\lnot p_1 \land \lnot p_2 \land ... \land \lnot p_n)
$$

和

$$
\lnot (p_1 \land p_2 \land ... \land p_n) \equiv (\lnot p_1 \lor \lnot p_2 \lor ... \lor \lnot p_n)
$$

用符号：

$$
\bigvee_{j=1}^{n}p_j
$$

来表示 $p_1 \lor p_2 \lor ... \lor p_n$，

用符号：

$$
\bigwedge_{j=1}^{n}p_j
$$

来表示 $p_1 \land p_2 \land ... \land p_n$。

德·摩根律可以简记为：

$$
\lnot (\bigvee_{j=1}^{n}p_j) \equiv \bigwedge_{j=1}^{n} \lnot p_j
$$

和

$$
\lnot (\bigwedge_{j=1}^{n}p_j) \equiv \bigvee_{j=1}^{n} \lnot p_j
$$

### 1.3.3 德·摩根律的运用

等价式 $\lnot(p \lor q) \equiv \lnot p \land \lnot q$告诉我们一个析取式的否定由各分命题否定的合取式组成。

等价式 $\lnot (p \land q) \equiv \lnot p \lor \lnot q$告诉我们一个合取式的否定由各分命题否定的析取式组成。

### 1.3.4 构造新的逻辑等价式

例6：证明 $\lnot (p \to q)$和 $p \land \lnot q$是逻辑等价的。

$$
\begin{align*}
\lnot (p \to q) & \equiv \lnot(\lnot p \land q) & \qquad &由条件析取等价式 \\
 & \equiv \lnot (\lnot p) \lor \lnot q & \qquad &由德·摩根第二定律 \\
& \equiv p \lor \lnot q & \qquad &由双重否定律

\end{align*}
$$

### 1.3.5 可满足性

一个复合命题称为是可满足的，如果存在一个对其变量的真值赋值使其为真（即当它是一个永真式或可满足式时）。当不存在这样的赋值时，即当复合命题对所有变量的真值赋值都是假的，则复合命题是不可满足的。

当我们找到一个特定的使得复合命题为真的真值赋值时，就证明了它是可满足的。这样的一个赋值称为这个特定的可满足性问题的一个解。

### 1.3.6 可满足性的应用

### 1.3.7 可满足性问题求解

## 1.4 谓词和量词

### 1.4.1 引言

命题路基不能表达数学语言和自然语言中所有语句的确切意思。

谓词逻辑，用来表达数学和计算机科学中各种语句的意义，并允许我们推理和探索对象之间的关系。

### 1.4.2 谓词

语句“x大于3”有两个部分：

- 第一部分：变量x是语句的主语
- 第二部分：谓词”大于3“，表明语句的主语具有一个性质

可以用P(x)表示语句“x大于3”，其中P表示谓词“大于3”，x是变量。语句P(x)也可以说成是命题函数P在x的值。一旦给变量x赋一个值，语句P(x)就成为命题并具有真值。

有些语句可以含有不止一个变量，比如： x=y+3，可以用Q(x, y)表示这个语句，其中x、y为变量，Q为谓词。当x和y被赋值时，语句Q(x, y)就有真值了。

可以令R(x, y, z)表示语句 x+y=z，当x、y、z被赋值时，此语句就有真值了。

一般的，涉及n个变量 $x_1, x_2, ..., x_n$的语句可以表示成：

$$
P(x_1, x_2, ..., x_n)
$$

形式为 $P(x_1, x_2, ..., x_n)$的语句是命题函数P在n元组 $(x_1, x_2, ..., x_n)$的值，P也称为n位谓词或n元谓词。

#### 前置条件和后置条件

谓词还可以用来验证计算机程序，也就是证明当给定合法输入时计算机程序总是能产生所期望的输出。描述合法输入的语句叫做：前置条件。程序运行的输出应满足的条件称为：后置条件。

### 1.4.3 量词

另外一种称为量化的重要方式也可以从命题函数生成一个命题。量化表示在何种程度上谓词对于一定范围的个体成立。

两类量化：

- 全称量化，它告诉我们一个谓词在所考虑范围内对每一个体都为真
- 存在量化，它告诉我们一个谓词对所考虑范围内的一个或多个个体为真。

处理谓词和量词的逻辑领域称为谓词演算。

量词：

| 命题               | 什么时候为真        | 什么时候为假        |
| ---------------- | ------------- | ------------- |
| $\forall x P(x)$ | 对每一个x，P(x)都为真 | 有一个x，使P(x)为假  |
| $\exists x P(x)$ | 有一个x，使P(x)为真  | 对每一个x，P(x)都为假 |

#### 全称量词

许多数学命题断言某一性质对于变量在某一特定域内的所有值均为真，这一特定域称为变量的论域（domain of discourse）或全体域（universe of discourse），简称为域（domain）。这类语句可以用全称量化表示。对特定论域而言P(x)的全称量化是这样一个命题：它断言P(x)对x在其论域中的所有值均为真。

定义1：

- P(x)的全称量化是语句：“P(x)对x在其论域的所有值为真”。 
- 符号 $\forall x P(x)$表示P(x)的全称量化，其中 $\forall$称为全称量词。命题 $\forall x P(x)$读作“对所有x，P(x)”或“对每个x，P(x)”。
- 一个使P(x)为假的个体称为 $\forall x P(x)$的反例。

全称量词：

- 对所有

- 对每个

- 全部的

- 对每一个

- 任意给定的

- 对任意的

- 对任一的

#### 存在量词

许多数学定理断言：有一个个体使得某种性质成立。这类语句可以用存在量化表示。可以用存在量化构成这样一个命题：该命题为真当且仅当论域中至少有一个x的值使得P(x)为真。

定义2：

- P(x)的存在量化是命题“论域中存在一个个体x满足P(x)”。
- 符号 $\exists x P(x)$表示P(x)的存在量化，其中 $\exists$称为存在量词。

存在量化 $\exists x P(x)$可读作“有一个x满足P(x)”、“至少有一个x满足P(x)”或“对某个x，P(x)”。

存在量词：

- 存在

- 对某些

- 至少有一个

- 有

#### 唯一性量词

唯一性量词，用符号 $\exists !$或 $\exists_{1}$表示。

$\exists ! x P(x)$或 $\exists_{1} x P(x)$这种表示法是指“存在一个唯一的x使得P(x)为真”。

唯一性量词：

- 存在一个唯一

- 恰好存在一个

- 有且只有一个

### 1.4.4 有限域上的量词

当一个量词的域是有限的时候，即所有元素可以一一列出时，量化语句就可以用命题逻辑来表达。

- 当论域中的元素为 $x_1, x_2, ..., x_n$，其中n是一个正整数，则全称量化 $\forall x P(x)$与合取式 $P(x_1) \land P(x_2) \land ... \land P(x_n)$相同，因为这一合取式为真当且仅当 $P(x_1), P(x_2), ..., P(x_n)$全部为真。

- 当论域中的元素为 $x_1, x_2, ..., x_n$，其中n是一个正整数，则存在量化 $\exists x P(x)$与析取式 $P(x_1) \lor P(x_2) \lor ... \lor P(x_n)$相同，因为该析取式为真当且仅当 $P(x_1), P(x_2), ..., P(x_n)$中至少一个为真。

#### 量化和循环的关系

在确定量化命题的真值时，借助循环与搜索来思考是有益的。当论域有无穷多个值时，这一搜索过程不适用。

### 1.4.5 受限域的量词

在要限定一个量词的论域时经常会采用简写的表示法。变量必须满足的条件直接放在量词的后面。

- 受限的全称量化和一个条件语句的全称量化等价。比如： $\forall x < 0 (x^2 > 0)$是表达 $\forall x (x < 0 \to x^2 > 0)$的另一种方式。

- 受限的存在量化和一个合取式的存在量化等价。比如： $\exists z > 0 (z^2=2)$是表达 $\exists z (z > 0 \land z^2 = 2)$的另一种方式

### 1.4.6 量词的优先级

量词 $\forall$和 $\exists$比命题演算中的所有逻辑运算符都具有更高的优先级。

### 1.4.7 变量绑定

当量词作用于变量x时，说此变量的这次出现为约束的。一个变量的出现被称为是自由的，如果没有被量词约束或设置为等于某一特定值。

命题函数中的所有变量出现必须是约束的或者被设置为等于某个特定值的，才能把它转变为一个命题。这可以通过采用一组全称量词、存在量词和赋值来实现。

逻辑表达式中一个量词作用到的部分称为这个量词的作用域。因此，一个变量是自由的，如果变量在公式中所有限定该变量的量词的作用于之外。

### 1.4.8 涉及量词的逻辑等价式

定义3：

涉及谓词和量词的语句是逻辑等价的当且仅当无论用什么谓词带入这些语句，也无论为这些命题函数里的变量指定什么论域，它们都有相同的真值。我们用 $S \equiv T$表示涉及谓词和量词的两个语句S和T是逻辑等价的。

- 全称量词对于一个合取式是可分配的（ $\forall x (P(x) \land Q(x)) \equiv \forall x P(x) \land \forall x Q(x)$），对析取式是不可分配的；

- 存在量词对于一个析取式是可分配的，对合取式是不可分配的。

### 1.4.9 量化表达式的否定

$$
\lnot \forall x P(x) \equiv \exists x \lnot P(x)
$$

$$
\lnot \exists x Q(x) \equiv \forall x \lnot Q(x)
$$

量词否定的规则称为量词的 德·摩根律。

量词的 德·摩根律：

| 否定                     | 等价语句                   | 何时为真       | 何时为假        |
| ---------------------- | ---------------------- | ---------- | ----------- |
| $\lnot \exists x P(x)$ | $\forall x \lnot P(x)$ | 对每个，P(x)为假 | 有x，使P(x)为真  |
| $\lnot \forall x P(x)$ | $\exists x \lnot P(x)$ | 有x使P(x)为假  | 对每个x，P(x)为真 |

### 1.4.10 语句到逻辑表达式的翻译

### 1.4.11 系统规范说明中量词的使用

### 1.4.13 逻辑程序设计

## 1.5    嵌套量词

### 1.5.1 引言

嵌套量词，即一个量词出现在另一个量词的作用域内。

### 1.5.2 理解涉及嵌套量词的语句

#### 将量化当作循环

### 1.5.3 量词的顺序

在没有其他量词的语句中，在不改变量化式意义的前提下，嵌套全称量词的顺序是可以改变的。

两个变量的量化式

| 语句                                                            | 何时为真                   | 何时为假                   |
| ------------------------------------------------------------- | ---------------------- | ---------------------- |
| $\forall x \forall y P(x, y)$、 $\forall y \forall x P(x, y)$  | 对每一对x、y，P(x, y)均为真     | 存在一对x、y，使得P(x, y)为假    |
| $\forall x \exists y P(x, y)$                                 | 对每个x，都存在一个y使得P(x, y)为真 | 存在一个x，使得P(x, y)对每个y总为假 |
| $\exists x \forall y P(x, y)$                                 | 存在一个x，使得P(x, y)对所有y均为真 | 对每个x，存在一个y使得P(x, y为假)  |
| $\exists x \exists y P(x, y)$ 、 $\exists y \exists x P(x, y)$ | 存在一对x、y，使得P(x, y)为真    | 对每一对x、y，P(x, y)均为假     |

### 1.5.4 数学语句到嵌套量词语句的翻译

### 1.5.5 嵌套量词到自然语言的翻译

第一步是写出表达式中量词和谓词的含义，第二步是用简单的句子来表达这个含义。

### 1.5.6 汉语语句到逻辑表达式的翻译

### 1.5.7 嵌套量词的否定

带嵌套量词语句的否定可以通过连续的应用单个量词语句的否定规则得到。

## 1.6 推理规则

### 1.6.1 引言

- 论证（argument）是指一连串的命题并以结论为最后的命题

- 有效性（valid）是指结论或论证的最后一个命题必须根据论证过程前面的命题或前提（premise）的真实性推出。

### 1.6.2 命题逻辑的有效论证

为了分析一个论证，我们用命题变量代替命题，这将一个论证改变为一个论证形式。一个论证的有效性来自于论证形式的有效性。

定义1：

命题逻辑中的一个论证是一连串的命题。除了论证中最后一个命题外都叫做前提，最后那个命题叫做结论。一个论证是有效的，如果它的所有前提为真蕴含着结论为真。

命题逻辑中的论证形式是一连串涉及命题变量的复合命题。无论用什么特定命题来替换其中的命题变量，如果前提均为真时结论为真，则称该论证形式是有效的。

### 1.6.3 命题逻辑的推理规则

永真式 $(p \land (p \to q)) \to q$是称为假言推理（modus ponens）或分离规则（law of detachment）的推理规则的基础。这个永真式导出了下面的有效论证形式：

$$
\begin{align*}
& p \\
& \underline{p \to q} \\
\therefore \ & q
\end{align*}
$$

推理规则：

| 推理规则                                                                                                  | 永真式                                                  | 名称    |
| ----------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | ----- |
| $$\begin{align*} & p \\ & \underline{p \to q} \\ \therefore \ & q \end{align*}$$                      | $(p \land (p \to q)) \to q$                          | 假言推理  |
| $$\begin{align*} & \lnot q \\ & \underline{p \to q} \\ \therefore \ & \lnot p \end{align*}$$          | $(\lnot q \land (p \to q)) \to \lnot p$              | 取拒式   |
| $$\begin{align*} & p \to q \\ & \underline{q \to r} \\ \therefore \ & p \to r \end{align*}$$          | $((p \to q) \land (q \to r)) \to (p \to r)$          | 假言三段论 |
| $$\begin{align*} & p \lor q \\ & \underline{\lnot p} \\ \therefore \ & q \end{align*}$$               | $((p \lor q) \land \lnot p) \to q$                   | 析取三段论 |
| $$\begin{align*} & p \\ \therefore \ & \overline{p \lor q} \end{align*}$$                             | $p \to (p \lor q)$                                   | 附加律   |
| $$\begin{align*} & \underline{p \land q} \\ \therefore \ & p \end{align*}$$                           | $(p \land q) \to p$                                  | 化简律   |
| $$\begin{align*} & p \\ & q \\ \therefore \ & \overline{p \land q} \end{align*}$$                     | $((p) \land (q)) \to (p \land q)$                    | 合取律   |
| $$\begin{align*} & p \lor q \\ & \underline{\lnot p \lor r} \\ \therefore \ & q \lor r \end{align*}$$ | $((p \lor q) \land (\lnot p \lor r)) \to (q \lor r)$ | 消解律   |

### 1.6.4 使用推理规则建立论证

### 1.6.5 消解律

消解律（resolution）推理规则基于永真式： $((p \lor q) \land (\lnot p \lor r)) \to (q \lor r)$。消解规则最后的析取式 $q \lor r$称为消解式（resolvent）。

要使用消解律作为仅有的推理规则来构造命题逻辑中的证明，假设和结论必须表示为子句（clause），这里子句是指变量或其否定的一个析取式。我们可以将命题逻辑中非子句的语句用一个或多个等价的子句语句来替换。

### 1.6.6 谬误

- 肯定结论的谬误（fallacy of affirming the conclusion）

- 否定假设的谬误（fallacy of denying the hypothesis）

### 1.6.7 量化命题的推理规则

#### 全称实例

全称实例（universal instantiation）是从给定前提 $\forall x P(x)$得出P(c)为真的推理规则，其中c是论域里的一个特定的成员。

全称实例：

$$
\begin{align*}
& \underline{\forall x P(x)} \\
\therefore \ & P(c)
\end{align*}
$$

#### 全称引入

全称引入（universal generalization）是从对论域里所有元素c都有P(c)为真的前提推出 $\forall x P(x)$为真的推理规则。

全称引入：

$$
\begin{align*}
& \underline{P(c)，任意c} \\
\therefore \ & \forall x P(x)
\end{align*}
$$

#### 存在实例

存在实例（eistential instantiation）是允许从“如果我们知道 $\exists x P(x)$为真，得出在论域中存在一个元素c使得P(c)为真”的推理规则。

存在实例：

$$
\begin{align*}
& \underline{\exists x P(x)} \\
\therefore \ & P(c)，对某个元素c
\end{align*}
$$

#### 存在引入

存在引入（existential generalization）是用来从“已知有一特定的c使P(c)为真时得出 $\exists x P(x)$为真”的推理规则。

存在引入：

$$
\begin{align*}
& \underline{P(c)，对某个元素c} \\
\therefore \ & \exists x P(x)
\end{align*}
$$

### 1.6.8 命题和量化命题推理规则的组合使用

全称实例和假言推理在一起使用，这种规则的组合有时称为全称假言推理（universal modus ponens）。如果 $\forall x (P(x) \to Q(x))$为真，并且如果P(a)对在全称量词论域中的一个特定元素a为真，那么Q(a)也肯定为真。

全称假言推理描述如下：

$$
\begin{align*}
& \forall x P(x) \to Q(x) \\
& \underline{P(a)，其中a是论域中一个特定的元素} \\
\therefore \ & Q(a)
\end{align*}
$$

全称取拒式（universal modus tollens）：将全称实例和取拒式组合在一起。可以用如下方式表达：

$$
\begin{align*}
& \forall x P(x) \to Q(x) \\
& \underline{\lnot Q(a)，其中a是论域中一个特定的元素} \\
\therefore \ & \lnot P(a)
\end{align*}
$$

## 1.7 证明导论

### 1.7.1 引言

非形式化证明（informal proof）。

定理证明几乎都是非形式化证明。

### 1.7.2 一些专用术语

定理（theorem）形式上就是一个能够被证明是真的语句。在数学描述中，定理通常用来专指那些被认为至少是有些重要的语句。不太重要的定理有时称为命题（定理也可称为事实（fact）或结论（result））。

一个定理可以是带一个或多个前提及一个结论的条件语句的全称量化式。它也可以是其他类型的逻辑语句。

用一个证明（proof）来展示一个定理是真的。证明就是建立定理真实性的一个有效论证。证明中用到的语句可以包括公理（axiom）（或假设（postulate）），这些是我们假定为真的语句、定理的前提和以前已经被证明的定理。

公理可以采用无须定义的原始术语来陈述，而在定理和证明中所用的所有其他术语都必须是有定义的。

一个重要性略低但有助于证明其他结论的定理称为引理（lemma）。

推论（corollary）是从一个已经被证明的定理可以直接建立起来的一个定理。

猜想（conjecture）是一个被提出认为是真的命题，通常是基于部分证据、启发式论证或专家的直觉。

### 1.7.3 理解定理是如何陈述的

### 1.7.4 证明定理的方法

### 1.7.5 直接证明法

### 1.7.6 反证法

直接证明法从定理的假设导向结论。

不从前提开始以结论结束来证明这类定理的方法叫做间接证明法。

反证法（proof of contraposition）。

空证明（vacuous proof）

平凡证明（trivial proof）

### 1.7.7 归谬证明法

归谬证明法（proof by contradiction）。

等价证明法。

反例证明法

### 1.7.8 证明中的错误

## 1.8 证明的方法和策略

### 1.8.1 引言

### 1.8.2 穷举证明和分情形证明法

### 1.8.3 存在性证明

### 1.8.4 唯一性证明

### 1.8.5 证明策略

### 1.8.6 寻找反例

。。。

# 第2章 基本结构：集合、函数、序列、求和与矩阵

由集合构建的离散结构包括：

- 组合：无需对象汇集，广泛用于计数；

- 关系：序偶的集合用于表示对象之间的关系；

- 图：结点和连接结点的边的集合；

- 有限状态机：为计算机器建模。

## 2.1 集合

### 2.1.1 引言

定义1：

集合是不同对象的一个无序的聚集，对象也称为集合的元素（element）或成员（member）。集合包含（contain）它的元素。我们用 $a \in A$来表示a是集合A中的一个元素。记号 $a \notin A$表示a不是集合A中的一个元素。

通常用大写字母来表示集合。小写字母表示集合中的元素。

在花括号之间列出所有元素的方法，这种描述集合的方式称为花名册方法（roster method）。

描述集合的另一种方式是使用集合构造器（set builder）符号。通过描述作为集合的成员必须具有的性质来刻画集合中的那些元素。一般的形式是采用记号{x|x具有性质P}，并读作满足P的所有x的集合。

常见集合：

- N = {0, 1, 2, 3, ...}，所有自然数的集合

- Z = {..., -2, -1, 0, 1, 2, ...}，所有整数的集合

- $Z^+ = \{ 1, 2, 3, ... \}$，所有正整数的集合

- $Q = \{ p/q | p \in Z, q \in Z, 且 q \neq 0\}$，所有有理数的集合

- R，所有实数的集合

- $R^+$，所有正实数的集合

- C，所有复数的集合

区间：

- [a, b]称为是从a到b的闭区间

- (a, b)称为是从a到b的开区间

计算机科学中的数据类型或类型的概念是建立在集合这一概念上的。特别的，数据类型或类型是一个集合连同作用于该集合对象上的一组操作的整体名称。例如：布尔（boolean）是集合{0, 1}的一个名称，连同对其上一个或多个元素实施运算，如AND、OR和NOT。

定义2：

两个集合相等当且仅当它们拥有同样的元素。所以，如果A和B是集合，则A和B是相等的当且仅当 $\forall x (x \in A \leftrightarrow x \in B)$。如果A和B是相等的集合，就记为A=B。

不含任何元素的集合，称为空集（empty set或null set），用 $\varnothing$表示。空集也可以用{}表示。

只有一个元素的集合叫做单元素集（singleton set）。

朴素集合论（native set theory）

### 2.1.2 文氏图

集合可用文氏图形象的表示。在文氏图中全集（universal set）U，包含所考虑的全部对象，用矩形框来表示。在矩形框内部，圆形或其他几何图形用于表示集合。有时候用点来表示集合中特定的元素。文氏图常用于表示集合之间的关系。

### 2.1.3 子集

定义3：

集合A是集合B的子集并且B是A的超集当且仅当A的每个元素也是B的元素。我们用记号 $A \subseteq B$表示集合A是集合B的子集。另外，如果我们要强调B是A的超集，可以用等价的记号 $B \supseteq A$（故 $A \subseteq B$和 $B \supseteq A$是等价的语句）。

$A \subseteq B$当且仅当量化式 $\forall x (x \in A \to x \in B)$为真。

定理1：

对于任意集合S，有：(i) $\varnothing \subseteq S$， (ii) $S \subseteq S$。

集合A是集合B的子集但是 $A \neq B$，就写成 $A \subset B$并说A是B的真子集。如果 $A \subset B$是真的，则必有 $A \subseteq B$且必有B的某个元素x不是A的元素。即A是B的真子集当且仅当 $\forall x (x \in A \to x \in B) \land \exists x (x \in B \land x \notin A)$为真。

### 2.1.4 集合的大小

定义4：

令S为集合。如果S中恰有n个不同的元素，这里n是非负整数，我们就说S是有限集，而n是S的基数。S的基数记为 $|S|$。

定义5：

一个集合称为是无限的，如果它不是有限的。

### 2.1.5 幂集

定义6：

给定集合S，S的幂集（power set）是集合S所有子集的集合。S的幂集记为 $\mathcal{P}(S)$。

如果一个集合有n个元素，那么它的幂集就有 $2^n$个元素。

### 2.1.6 笛卡儿积

定义7：

有序n元组（ordered n-tuple） $(a_1, a_2, ..., a_n)$是以 $a_1$为第1个元素， $a_2$为第2个元素， ...， $a_n$为第n个元素的有序聚集。

两个有序n元组是相等的当且仅当每一对对应的元素都相等。

有序二元组称为序偶（ordered pair）。

定义8：

令A和B为集合。A和B的笛卡儿积（Cartesian product）用 $A \times B$表示，是所有序偶(a, b)的集合，其中 $a \in A$且 $b \in B$。于是， $A \times B = \{ (a, b) | a \in A \land b \in B \}$。

注意笛卡儿积 $A \times B$和 $B \times A$是不相等的，除非 $A = \varnothing$ 或 $B = \varnothing$。

定义9：

集合 $A_1, A_2, ..., A_n$的笛卡儿积用 $A_1 \times A_2 \times ... \times A_n$表示，是有序n元组 $(a_1, a_2, ..., a_n)$的集合，其中 $a_i$属于 $A_i , i = 1, 2, ..., n$。换言之， $A_1 \times A_2 \times ... \times A_n = \{ (a_1, a_2, ..., a_n) | a_i \in A_i, i = 1, 2, ..., n\}$

记号 $A^2$表示 $A \times A$，即集合A和自身的笛卡儿积。更一般的： $A^n = { (a_1, a_2, ..., a_n) | a_i \in A, i = 1, 2, ..., n}$。

笛卡儿积 $A \times B$的一个子集R被称为从集合A到集合B的关系（relation）。R的元素是序偶，其中第一个元素属于A而第二个元素属于B。

从集合A到其自身的一个关系称为是A上的一个关系。

### 2.1.7 使用带量词的集合符号

- $\forall x \in S(P(x))$表示P(x)在集合S所有元素上的全称量化。即 $\forall x (x \in S \to P(x))$。

- $\exists x \in S(P(x))$表示P(x)在集合S所有元素上的存在量化。即 $\exists x(x \in S \land P(x))$。

### 2.1.8 真值集和量词

给定谓词P和论域D，定义P的真值集（truth set）为D中使P(x)为真的元素x组成的集合。P(x)的真值集记为 $\{x \in D | P(x)\}$。

$\forall x P(x)$在论域U上为真当且仅当P的真值集是集合U。 $\exists x P(x)$在论域U上为真当且仅当P的真值集非空。

## 2.2 集合运算

### 2.2.1 引言

定义1：

令A和B为集合。集合A和B的并集，用 $A \cup B$表示，是一个集合，它包含A或B中或同时在A和B中的元素。

一个元素x属于A和B的并集当且仅当x属于A或x属于B， $A \cup B = \{x | x \in A \lor x \in B\}$。

定义2：

令A和B为集合。集合A和B的交集，用 $A \cap B$表示，是一个集合，它包含同时在A和B中的那些元素。

一个元素x属于集合A和B的交集当且仅当x属于A而且x属于B， $A \cap B = \{ x | x \in A \land x \in B\}$。

定义3：

两个集合称为是不相交的，如果它们的交集为空集。

$|A \cup B| = |A| + |B| - |A \cap B|$，把这一结果推广到任意多各集合的并集就是所谓的包含排斥原理，简称容斥原理（principle of inclusion-exclusion）。

定义4：

令A和B为集合。A和B的差集，用 $A - B$表示，是一个集合，它包含属于A而不属于B的元素。A和B的差集也称为B相对于A的补集。

集合A和集合B的差集有时也记为 $A \setminus B$。

一个元素x属于A和B的差集当且仅当 $x \in A$且 $x \notin B$， $A - B = \{x | x \in A \land x \notin B\}$。

定义5：

令U为全集。集合A的补集，用 $\overline{A}$，是A相对于U的补集。所以集合A的补集是 $U - A$。

一个元素x属于 $\overline{A}$当且仅当 $x \notin A$。 $\overline{A} = \{x \in U | x \notin A\}$。

### 2.2.2 集合恒等式

| 恒等式                                                    | 名称    |
| ------------------------------------------------------ | ----- |
| $A \cap U = A$                                         | 恒等律   |
| $A \cup \varnothing = A$                               | 恒等律   |
| $A \cup U = U$                                         | 支配律   |
| $A \cap \varnothing = \varnothing$                     | 支配律   |
| $A \cup A = A$                                         | 幂等律   |
| $A \cap A = A$                                         | 幂等律   |
| $\overline{(\overline{A})} = A$                        | 补律    |
| $A \cup B = B \cup A$                                  | 交换律   |
| $A \cap B = B \cap A$                                  | 交换律   |
| $A \cup (B \cup C) = (A \cup B) \cup C$                | 结合律   |
| $A \cap (B \cap C) = (A \cap B) \cap C$                | 结合律   |
| $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$       | 分配律   |
| $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$       | 分配律   |
| $\overline{A \cap B} = \overline{A} \cup \overline{B}$ | 德·摩根律 |
| $\overline{A \cup B} = \overline{A} \cap \overline{B}$ | 德·摩根律 |
| $A \cup (A \cap B) = A$                                | 吸收律   |
| $A \cap (A \cup B) = A$                                | 吸收律   |
| $A \cup \overline{A} = U$                              | 互补律   |
| $A \cap \overline{A} = \varnothing$                    | 互补律   |

证明集合恒等式的方法：

- 子集方法：证明恒等式的每一边是另一边的子集

- 成员表：对于原子集合的每一种可能的组合，证明恰好在这些原子集合中的元素要么同时属于两边，要么都不属于两边

- 应用已知的恒等式：从一边开始，通过应用一系列已经建立了的恒等式将它转换成另一边的形式。

### 2.2.3 扩展的并集和交集

定义6：

一组集合的并集是包含那些至少是这组集合中一个集合成员的元素的集合。

用以下记号：

$$
A_1 \cup A_2 \cup ... \cup A_n = \bigcup_{i=1}^n A_i
$$

表示集合 $A_1, A_2, ..., A_n$的并集。

定义7：

一组集合的交集是包含那些属于这组集合中所有成员集合的元素的集合。

用以下记号：

$$
A_1 \cap A_2 \cap ... \cap A_n = \bigcap_{i=1}^n A_i
$$

表示集合 $A_1, A_2, ..., A-n$的交集。

### 2.2.4 集合的计算机表示

假定全集U是有限的。首先为U的元素任意规定一个顺序，例如 $a_1, a_2, ..., a_n$。于是利用长度为n的比特串来表示U的子集A：其中比特串中第i位是1，如果 $a_i$属于A；是0，如果 $a_i$不属于A。

### 2.2.5 多重集

多重集（multiset，多重成员集），就是一个元素的无序集，其中元素作为成员可以出现多于一次。记号 $\{ m_1 \cdot a_1, m_2 \cdot a_2, ..., m_n \cdot a_n \}$表示多重集，其中元素 $a_1$出现了 $m_1$次，元素 $a_2$出现了 $m_2$次，以此类推。这里 $m_i, i = 1, 2, ..., r$称为元素 $a_i, i = 1, 2, ..., r$的重复数（multiplicity）。多重集的基数是其元素的重复数的总和。

设P和Q是多重集：

- 多重集P和Q的并是多重集，记作 $P \cup Q$，其中元素的重复数是它在P和Q中重复数的最大值。

- P和Q的交是多重集，记作 $P \cap Q$，其中元素的重复数是它在P和Q中重复数的最小值。

- P和Q的差是多重集，记作 $P -Q$，其中元素的重复数是它在P中的重复数减去在Q中的重复数，如果差为负数，重复数就为0。

- P和Q的和是多重集，记作 $P + Q$，其中元素的重复数是它在P和Q中的重复数之和。

## 2.3 函数

### 2.3.1 引言

定义1：

令A和B为非空集合。从A到B的函数f是对元素的一种指派，对A的每个元素恰好指派B的一个元素。如果B中元素b是唯一由函数f指派给A中元素a的，则我们就写成f(a)=b。如果f是从A到B的函数，就写成 $f: A \to B$。

函数有时也称映射（mapping）或者变换（transformation）。

定义2：

如果f是从A到B的函数，我们说A是f的定义域（domain），而B是f的陪域（codomain）。如果f(a)=b，我们说b是a的像（image），而a是b的原像（preimage）。f的值域（range）或像是A中元素的所有像的集合。如果f是从A到B的函数，我们说f把A映射（map）到B。

当两个函数有相同的定义域、陪域，定义域中的每个元素映射到陪域中相同的元素时，这两个函数是相等的。

一个函数称为是实值函数，如果其陪域是实数集合；称为整数值函数如果其陪域是整数集合。具有相同定义域的两个实值函数或两个整数值函数可以相加和相乘。

定义3：

令 $f_1$和 $f_2$是从A到R的函数，那么 $f_1 + f_2$和 $f_1f_2$也是从A到R的函数，其定义为对于任意 $x \in A$：

$$
(f_1 + f_2)(x) = f_1(x) + f_2(x) \\
(f_1f_2)(x) = f_1(x)f_2(x)
$$

定义4：

令f为从A到B的函数，S为A的一个子集。S在函数f下的像是由S中元素的像组成的B的子集。我们用f(S)表示S的像，于是 $f(S) = \{ t | \exists s \in S(t=f(s))\}$，我们也用简写 $\{f(s)|s \in S\}$来表示这个集合。

### 2.3.2 一对一函数和映上函数

定义5：

函数f称为是一对一（one-to-one）或单射（injection）函数，当且仅当对于f的定义域中的所有a和b有f(a)=f(b)蕴涵a=b。一个函数如果是一对一的，就成为是单射的（injective）。

定义6：

定义域和陪域都是实数集子集的函数f称为是递增的，如果对f的定义域中的x和y，当x<y时有 $f(x) \leq f(y)$；称为是严格递增的，如果当x < y时有 $f(x) < f(y)$。f称为是递减的，如果对f的定义域中的x和y，当x<y时有 $f(x) \geq f(y)$；称为是严格递减的，如果当 $x<y$时有 $f(x) > f(y)$。

定义7：

一个从A到B的函数f称为映上（onto）或满射（surjection）函数，当且仅当对每个 $b \in B$有元素 $a \in A$使得f(a)=b。一个函数f如果是映上的就称为是满射的（surjective）。

定义8：

函数f是一一对应（one-to-one correspondence）或双射（bijection）函数，如果它既是一对一的又是映上的。这样的函数称为是双射的（bijective）。



### 2.3.3 反函数和函数合成

定义9：

令f为从集合A到集合B的一一对应。f的反函数（或逆函数）是这样的函数，它指派给B中元素b的是A中使得f(a)=b的唯一元素a。f的反函数用 $f^{-1}$表示。于是当 f(a)=b时 $f^{-1}(b) = a$。

一一对应关系被称为可逆的（invertible），因为可以定义这个函数的反函数。如果函数不是一一对应关系，就说它是不可逆的（not invertible），因为这样的函数不存在反函数。

定义10：

令g为从集合A到集合B的函数，f是从集合B到集合C的函数，函数f和g的合成（composition）记作 $f \circ g$，定义为对任意 $a \in A$，有 $(f \circ g)(a) = f(g(a))$。

### 2.3.4 函数的图

定义11：

令f为从集合A到集合B的函数，函数f的图是序偶集合 $\{(a, b) | a \in A 且 f(a)=b\}$。

### 2.3.5 一些重要的函数

定义12：

下取整函数（floor）指派给实数x的是小于或等于x的最大整数。下取整函数在x的值用 $\lfloor x \rfloor$表示。上取整函数（ceiling）指派给实数x的是大于或等于x的最小整数。上取整函数在x的值用 $\lceil x \rceil$表示。

上取整函数和下取整函数的有用性质（n为整数，x为实数）：


| 序号   | 性质                                                              |
| ---- | --------------------------------------------------------------- |
| （1a） | $\lfloor x \rfloor = n当且仅当 n \leq x < n+1$                      |
| （1b） | $\lceil x \rceil = n 当且仅当 n - 1 < x \leq n$                     |
| （1c） | $\lfloor x \rfloor = n当且仅当 x - 1 < n \leq x$                    |
| （1d） | $\lceil x \rceil = n 当且仅当 x \leq n < x + 1$                     |
| （2）  | $x - 1 < \lfloor x \rfloor \leq x \leq \lceil x \rceil < x + 1$ |
| （3a） | $\lfloor -x \rfloor = - \lceil x \rceil$                        |
| （3b） | $\lceil -x \rceil = - \lfloor x \rfloor$                        |
| （4a） | $\lfloor x + n \rfloor = \lfloor x \rfloor + n$                 |
| （4b） | $\lceil x + n \rceil = \lceil x \rceil + n$                     |

阶乘函数 $f: N \to Z^{+}$，记为 $f(n)=n!$。 $f(n) = n!$的值是前n个正整数的乘积，因此 $f(n) = 1 \cdot 2 ... (n - 1) \cdot n [并且 f(0) = 0! = 1]$。

### 2.3.6 部分函数

定义13：

一个从集合A到集合B的部分函数（partial function）f是给A的一个子集（称为f的定义域（domain of definition））中的每个元素a指派B中唯一的元素b。集合A和B分别称为f的域和陪域。我们说f对于A中但不在f的定义域中的元素无定义（undefined）。当f的定义域等于A时，就说f是全函数（total function）。

## 2.4 序列与求和

### 2.4.1 引言

### 2.4.2 序列

序列是一种用来表示有序列表的离散结构。

定义1：

序列（sequence）是一个从整数集的一个子集（通常是集合{0, 1, 2, ...}或集合{1, 2, 3, ...}）到一个集合S的函数。用记号 $a_n$表示整数n的像。称 $a_n$为序列的一个项（term）。

我们用记号 $\{ a_n \}$来描述序列。

定义2：

几何级数是如下形式的序列： $a, ar, ar^2, ..., ar^n, ...$，其中初始项a和公比r都是实数。

几何级数是指数函数 $f(x)=ar^x$的离散的对应体。

定义3：
算术级数是如下形式的序列： $a, a + d, a + 2d, ..., a + nd, ...$，其中初始项a和公差d都是实数。

算术级数是线性函数 $f(x) = dx + a$的离散的对应体。

在计算机科学中经常使用形如 $a_1, a_2, ..., a_n$的序列，这些有穷序列也称为串（string）。串的长度是这个串的项数。空串是没有任何项的串，记作 $\lambda$。空串的长度为0。

### 2.4.3 递推关系

定义4：

关于序列 $\{a_n\}$的递推关系（recurrence relation）是一个等式，对所有满足 $n \geq n_0$的n，它把 $a_n$用序列中前面项即 $a_0, a_1, ..., a_{n-1}$中的一项或多项来表示，这里 $n_0$是一个非负整数。如果一个序列的项满足递推关系，则该序列就称为是递推关系的一个解。（递推关系递归的定义了一个序列。）

定义5：

斐波那契数列 $f_0, f_1, f_2, ...$由初始条件 $f_0 = 0、f_1 = 1$和下列递推关系所定义： $f_n = f_{n-1} + f_{n-2} \quad n = 2, 3, 4, ...$。

当我们为序列的项找到一个显式公式--闭公式（closed formula）时，我们就说求解了带有初始条件的递推关系。

迭代（iteration）。

- 正向替换：从初始条件出发找到连续的项直到 $a_n$为止。
- 反向替换：从 $a_n$开始迭代时将其表示为序列中前面的项直到可以用 $a_1$来表示。

### 2.4.4 特殊的整数序列


### 2.4.5 求和

求和记号（summation natation）。

用来表达序列 $\{a_n\}$中项 $a_m, a_{m+1}, ..., a_n$之和的记号，用记号：

$$
\sum_{j=m}^{n} a_j \quad 或 \quad \sum_{m \leq j \leq n} a_j
$$

（读作 $a_j$从j=m到j=n的和）来表示 $a_m + a_{m+1} + ... + a_n$，此处变量j称为求和下标，而字母j作为变量可以是任意的，即可以使用任何其他字母，比如i或k。此处求和下标依次遍历从下限m到上限n为止的所有整数。用 $\sum$表示求和。

定理1给出几何级数的项求和公式。

定理1：

如果a和r都是实数且 $r \neq 0$，则 

$$
\sum_{j=0}^n ar^j = 

\begin{cases}
\frac{ar^{n+1} - a}{r - 1} & r \neq 1 \\
(n + 1)a & r = 1
\end{cases}
$$


## 2.5 集合的基数

### 2.5.1 引言

定义1：

集合A和集合B有相同的基数（cardinality），当且仅当存在从A到B的一个一一对应。当A和B有相同的基数时，就写成 $|A| = |B|$。

定义2：

如果存在一个从A到B的一对一函数，则A的基数小于或等于B的基数，并写成 $|A| \leq |B|$。再者，当 $|A| \leq |B|$并且A和B有不同的基数时，我们说A的基数小于B的基数，并写成 $|A| < |B|$。

### 2.5.2 可数集合

定义3：

一个集合或者是有限集或者与自然数集具有相同的基数，这个集合就称为可数的（countable）。一个集合不是可数的，就称为不可数的（uncountable）。如果一个无限集S是可数的，我们用符号 $\aleph$来表示集合S的基数（这里 $\aleph$是阿里夫，希伯来语字母表的第一个字母），写作 $|S| = \aleph$，并说S有基数“阿里夫零”。

### 2.5.3 不可数集合

#### 有关基数的结果

定理1：

如果A和B是可数集合，则 $A \cup B$也是可数集合。

定理2：

Schröder-Bernstein定理 如果A和B是集合且 $|A| \leq |B|$和 $|B| \leq |A|$，则 $|A| = |B|$。换言之，如果存在一对一函数f从A到B和g从B到A，则存在A和B之间的一一对应函数。

#### 不可计算函数

定义4：

一个函数称为是可计算的（computable），如果存在某种编程语言写的计算机程序能计算该函数的值。如果一个函数不是可计算的，就说是不可计算的（uncomputable）。

#### 连续统假设


## 2.6 矩阵

### 2.6.1 引言

用矩阵表示集合中元素之间的关系。

定义1：

矩阵（matrix）是矩形状的数组。m行n列的矩阵称为 $m \times n$矩阵。行数和列数相同的矩阵称为方阵（square）。如果两个矩阵有同样数量的行和列且每个位置上的对应项都相等，则这两个矩阵是相等的。

定义2：

令m和n是正整数，并令

$$
A = 
\begin{bmatrix}
a_{11} & a_{12} & ... & a_{1n} \\
a_{21} & a_{22} & ... & a_{2n} \\
\vdots & \vdots & & \vdots \\
a_{m1} & a_{m2} & ... & a_{mn}
\end{bmatrix}
$$

A的第i行是 $1 \times n$矩阵 $[a_{i1}, a_{i2}, ..., a_{in}]$。A的第j列是 $n \times 1$矩阵

$$
\begin{bmatrix}
a_{1j} \\
a_{2j} \\
\vdots \\
a_{mj}
\end{bmatrix}
$$

。A的第(i, j)元素（element）或项（entry）是元素 $a_{ij}$，即A的第i行第j列位置上的数。表示矩阵A的一个方便的简写符号是写成 $A=[a_{ij}]$，表示A是其第(i, j)元素为 $a_{ij}$的矩阵。

### 2.6.2 矩阵算术

定义3

令 $A = [a_{ij}]$和 $B = [b_{ij}]$为 $m \times n$矩阵。A和B的和，记作 $A + B$，是其第(i, j)元素为 $a_{ij} + b_{ij}$的矩阵。换言之， $A + B = [a_{ij} + b_{ij}]$。

相同大小的两个矩阵的和是将它们对应位置上的元素相加得到的。不同大小的矩阵不能相加。

两个矩阵的成绩只有在第一个矩阵的列数和第二个矩阵的行数相等时才有定义。

定义4

令A为 $m \times k$矩阵，B为 $k \times n$矩阵。A和B的乘积，记作AB，是一个 $m \times n$矩阵，其第(i, j)元素等于A的第i行与B的第j列对应元素的乘积之和。换言之，如果 $AB = [c_{ij}]$，则 $c_{ij} = a_{i1}b_{1j} + a_{i2}b_{2j} + ... + a_{ik}b_{kj}$。

矩阵乘法是可结合的，但是，矩阵乘法不是可交换的。

### 2.6.3 矩阵的转置和幂

定义5

n阶单位矩阵（identity matrix of order n）是 $n \times n$矩阵 $I_n = [\delta_{ij}]$（克罗内克积（kronecker delta）），其中 $\delta_{ij}=1$如果i=j， $\delta_{ij} = 0$如果 $i \neq j$。因此

$$
I_{ij} = 
\begin{bmatrix}
1 & 0 & \cdots & 0 \\
0 & 1 & \cdots & 0 \\
\vdots & \vdots & & \vdots \\
0 & 0 & \cdots & 1
\end{bmatrix}
$$

一个矩阵乘以一个大小合适的单位阵不会改变该矩阵。换言之，当A是一个 $m \times n$矩阵时，有 $AI_n = I_mA = A$。

可以定义方阵的幂次。当A是一个 $n \times n$矩阵时，则有 

$$
A_0 = I_n, \quad A^r = \underbrace{AAA \cdots A}_{r个相乘}
$$

定义6

令 $A=[a_{ij}]$为 $m \times n$矩阵。A的转置（transpose）记作 $A^T$，是通过交换A的行和列所得到的 $n \times m$矩阵。换言之，如果 $A^T = [b_{ij}]$，则 $b_{ij} = a_{ji}, i = 1, 2, ..., n, j = 1, 2, ..., m$。

定义7

方阵A称为对称的（symmetric），如果 $A = A^T$。因此 $A=[a_{ij}]$为对称的，如果对所有i和j ( $1 \leq i \leq n, 1 \leq j \leq n$)，有 $a_{ij} = a_{ji}$。

### 2.6.4 0-1矩阵

所有元素非0即1的矩阵称为0-1矩阵。

定义8

令 $A = [a_{ij}]$和 $B = [b_{ij}]$为 $m \times n$阶0-1矩阵。A和B的并是0-1矩阵，其(i, j)元素为 $a_{ij} \lor b_{ij}$。A和B的并记作 $A \lor B$。A和B的交是0-1矩阵，其(i, j)元素是 $a_{ij} \land b_{ij}$。A和B的交记作 $A \land B$。

定义9

令 $A=[a_{ij}]$为 $m \times k$阶0-1矩阵， $B=[b_{ij}]$为 $k \times n$阶0-1矩阵。A和B的布尔积（Boolean product），记作 $A \odot B$，是 $m \times n$矩阵 $[c_{ij}]$，其中 $c_{ij} = (a_{i1} \land b_{1j}) \lor (a_{i2} \land b_{2j}) \lor \cdots \lor (a_{ik} \land b_{kj})$。

定义10

令A为0-1方阵，r为正整数。A的r次布尔幂是r个A的布尔积。A的r次布尔幂记作 $A^{[r]}$。因此 

$$
A^{[r]} = \underbrace{A \odot A \odot A \cdots \odot A}_{r个A}
$$

