# 第1章 绪论

## 1.1 数据结构的研究内容

## 1.2 数据结构的基本概念和术语

### 1.2.1 数据、数据元素、数据项和数据对象

- 数据（Data）是客观事物的符号表示，是所有能输入计算机中并被计算机程序处理的符号的总称。
- 数据元素（Data Element）是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。数据元素也称为元素、记录等。数据元素用于完整地描述一个对象。
- 数据项（Data Item）是组成数据元素的、有独立含义的、不可分割的最小单位。
- 数据对象（Data Object）是性质相同的数据元素的集合，是数据的一个子集。

### 1.2.2 数据结构

数据结构（Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合。

数据结构包括逻辑结构和存储结构两个层次。

#### 1. 逻辑结构

数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作从具体问题中抽象出来的数学模型。

数据的逻辑结构有两个要素：

- 数据元素
- 关系，是指数据元素之间的逻辑关系。

数据的逻辑结构通常有4类基本逻辑结构：

- 集合结构：数据元素之间除了“属于同一集合”的关系外，别无其他关系。
- 线性结构：数据元素之间存在一对一的关系。
- 树结构：数据元素之间存在一对多的关系。
- 图结构（或网状结构）：数据元素之间存在多对多的关系。

集合结构、树结构、图结构（或网状结构）都属于非线性结构。

线性结构包括：

- 线性表
- 栈和队列
- 字符串
- 数组
- 广义表

非线性结构包括：

- 树结构：
	- 树：具有多个分支的层次结构
	- 二叉树：具有两个分支的层次结构
- 图结构：
	- 有向图
	- 无向图
- 集合结构

#### 2. 存储结构

数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构。数据元素在计算机中有两种基本的存储结构：

- 顺序存储结构：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。
- 链式存储结构：顺序存储结构要求所有元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。为了表示节点之间的关系，需要给每个节点附加指针字段，用于存放后继元素的存储地址。链式存储结构通常借助于程序设计语言的指针类型来描述。

### 1.2.3 数据类型和抽象数据类型

#### 1. 数据类型

数据类型（Data Type）是一个值的集合和定义在这个值集上的一组操作的总称。

#### 2. 抽象数据类型

抽象数据类型（Abstract Data Type， ADT）一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括3个部分：数据对象、数据对象上关系的集合以及数据对象的基本操作的集合。

抽象数据类型的定义格式如下：

```c
ADT 抽象数据类型名 {
	数据对象: <数据对象的定义>
	数据关系: <数据关系的定义>
	基本操作: <基本操作的定义>
} ADT 抽象数据类型名
```

其中，数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作的定义格式为：

```c
基本操作名(参数表)
	初始条件: <初始条件描述>
	操作结果: <操作结果描述>
```

- 基本操作有两种参数：
	- 赋值参数：只为操作提供输入值；
	- 引用参数：以&打头，除可提供输入值外，还将返回操作结果。
- 初始条件：描述了操作执行之前数据结构和参数应满足的条件，若初始条件为空，则省略。
- 操作结果：说明了操作正常完成之后，数据结构的变化状况和应返回的结果。

## 1.3 抽象数据类型的表示与实现

（1）预定义常量及类型：

```c
// 函数结果状态码
#define OK 1
#define ERROR 0
#define OVERFLOW -2

// Status是函数返回值类型，其值是函数结果状态代码。
typedef int Status;
```

（2）数据结构的表示（存储结构）用类型定义（typedef）描述；数据元素类型约定为ElemType，由用户在使用该数据类型时自行定义。
（3）基本操作的算法用如下格式的函数来描述：

```c
函数类型 函数名(函数参数表)
{
	// 算法说明
	语句序列
} // 函数名
```

当函数返回值为函数结果状态代码时，函数定义为Status类型。在形参中，以&打头的参数为引用参数。
（4）内存的动态分配与释放，使用new和delete动态分配和释放内存空间：

- 分配空间： `指针变量 = new 数据类型;`
- 释放空间： `delete 指针变量;`

（5）赋值语句：

- 简单赋值： `变量名 = 表达式;`
- 串联赋值： `变量名1 = 变量名2 = ... = 变量名n = 表达式;`
- 成组赋值： `(变量名1, ..., 变量名n) = (表达式1, ..., 表达式n);`
- 结构赋值： `结构名1 = 结构名2;`、 `结构名 = (值1, 值2, ..., 值n);`
- 条件赋值： `变量名 = 条件表达式 ? 表达式T : 表达式F;`
- 交换赋值： `变量名1 <--> 变量名2;`

（6）选择语句：

- 条件语句1： `if (表达式) 语句;`
- 条件语句2：
```c
if (表达式) 语句;
else 语句;
```
- 开关语句：
```c
switch (表达式)
{
	case 值1: 语句序列1; break;
	case 值2: 语句序列2; break;
	...
	case 值n: 语句序列n; break;
	default: 语句序列n+1;
}
```

（7）循环语句：

- for语句： `for (表达式1; 条件; 表达式2) 语句;`
- while语句： `while (条件) 语句;`
- do-while语句：
```c
do {
	语句序列;
} while (条件);
```

（8）结束语句：

- 函数结束语句：
	- `return 表达式;`
	- `return;`
	- case或循环结束语句 `break;`
	- 异常结束语句 `exit (异常代码);`

（9）输入输出语句使用C++流式输入输出的形式：

- 输入语句： `cin >> 变量1 >> ... >> 变量n;`
- 输出语句： `cout << 表达式1 << ... << 表达式n;`

（10）基本函数：

- 求最大值： `Max (表达式1, ..., 表达式n)`
- 求最小值： `Min (表达式1, ..., 表达式n)`

## 1.4 算法和算法分析

### 1.4.1 算法的定义及特性

算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。

一个算法必须满足以下5各重要特性：

- 有穷性：一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
- 确定性：对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，算法的执行者或阅读者都能明确其含义及如何执行。
- 可行性：算法中的所有操作都可以通过将已经实现的基本操作运算执行有限次来实现。
- 输入：一个算法有0个或多个输入。
- 输出：一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。

### 1.4.2 评价算法优劣的基本标准

- 正确性
- 可读性
- 健壮性
- 高效性：高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。

### 1.4.3 算法的时间复杂度

衡量算法效率的方法主要有两类：

- 事后统计法
- 事前分析估算法

#### 1. 问题规模和语句频度

问题规模，是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。n越大算法的执行时间越长。

一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句重复执行次数和执行一次所需时间的乘积。

一条语句的重复执行次数称作语句频度（Frequency Count）。

设每条语句执行依次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量。

#### 2. 算法的时间复杂度定义

用O表示数量级。

一般情况下，算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作： T(n) = O(f(n))，它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度（Time Complexity）。

数学符号O的严格定义为：若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)=O(f(n))表示存在正的常数C和 $n_0$，使得当 $n \geq n_0$时都满足 $0 \leq T(n) \leq Cf(n)$。

该定义说明了函数T(n)和f(n)具有相同的增长趋势，并且T(n)的增长至多趋向于函数f(n)的增长。符号O用来描述增长率的上限，它表示当问题规模 $n > n_0$时，算法的执行时间不会超过f(n)。

#### 3. 算法的时间复杂度分析举例

分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模n的某个函数f(n)，取其数量级用符号O表示即可。

**定义1.1** 若 $f(n) = a_m n^m + a_{m - 1} n^{m - 1} + \cdots + a_1 n + a_0$是一个m次多项式，则 $T(n)=O(n^m)$。

- 算法的执行时间是一个与问题规模n无关的常数，算法的时间复杂度为T(n)=O(1)，称为常量阶。
	- 如果算法的执行时间不随问题规模n的增长而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是O(1)。
- 算法的时间复杂度为T(n)=O(n)，称为线性阶。
- 算法的时间复杂度为 $T(n) = O(n^2)$，称为平方阶。
- 算法的时间复杂度为 $T(n) = O(n^3)$，称为立方阶。
- 算法的时间复杂度为 $T(n) = O(\log_2n)$，称为对数阶。

常见的时间复杂度按数量级递增排列依次为：

- 常量阶O(1)，
- 对数阶 $O(\log_2n)$，
- 线性阶O(n)，
- 线性对数阶 $O(n \log_2n)$，
- 平方阶 $O(n^2)$，
- 立方阶 $O(n^3)$，
- $\cdots \cdots$，
- k次方阶 $O(n^k)$，
- 指数阶 $O(2^n)$。

#### 4. 最好、最坏和平均时间复杂度

- 算法在最好情况下的时间复杂度为最好时间复杂度，是指算法计算量可能达到的最小值；
- 算法在最坏情况下的时间复杂度为最坏时间复杂度，是指算法计算量可能达到的最大值；
- 算法的平均时间复杂度是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。

### 1.4.4 算法的空间复杂度

采用渐进空间复杂度（Space Complexity）作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n的函数，记作S(n)=O(f(n))。

若算法执行时所需要的辅助空间相对于输入数据量而言是个常数，则称这个算法在原地工作，辅助空间为O(1)。

## 1.5 小结

# 第2章 线性表

## 2.1 线性表的定义和特点

由 $n (n \geq 0)$个数据特性相同的元素构成的有限序列，称为线性表。

线性表中元素的个数 $n (n \geq 0)$定义为线性表的长度，当n=0时称之为空表。

对于非空的线性表或线性结构，特点是：

- 存在唯一的一个被称作“第一个”的数据元素；
- 存在唯一的一个被称作“最后一个”的数据元素；
- 除第一个元素之外，结构中的每个数据元素均只有一个前驱；
- 除最后一个元素之外，结构中的每个数据元素均只有一个后继。

## 2.2 案例引入


## 2.3 线性表的类型定义

数据对象： $D = \{a_i | a_i \in \mathrm{ElemSet}, i = 1, 2, \cdots, n, n \geq 0 \}$
数据关系： $R = \{<a_{i - 1}, a_i> | a_{i - 1}, a_{i} \in D, i = 2, \cdots, n \}$


```c
ADT List {
	数据对象：参照上面的数据对象
	数据关系：参照上面的数据关系
	基本操作：
		InitList(&L)
			操作结果：构造一个空的线性表L。
			
		DestroyList(&L)
			初始条件：线性表L已存在。
			操作结果：销毁线性表L。

		ClearList(&L)
			初始条件：线性表L已存在。
			操作结果：将L重置为空表。
		
		ListEmpty(L)
			初始条件：线性表L已存在。
			操作结果：若L为空表，则返回true，否则返回false。
		
		ListLength(L)
			初始条件：线性表L已存在。
			操作结果：返回L中数据元素的个数。
		
		GetElem(L, i, &e)
			初始条件：线性表L已存在，且 1 ≤ i ≤ ListLength(L)。
			操作结果：用e返回L中第i各数据元素的值。
		
		LocateElem(L, e)
			初始条件：线性表L已存在。
			操作结果：返回L中第1个值与e相同的元素在L中的位置。若这样的数据元素不存在，则返回值为0。
		
		PriorElem(L, cur_e, &pre_e)
			初始条件：线性表L已存在。
			操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回其前驱，否则操作失败，pre_e无定义。
		
		NextElem(L, cur_e, &next_e)
		　　 初始条件：线性表L已存在。
		　　 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回其后继，否则操作失败，next_e无定义。
		
		ListInsert(&L, i, e)
		　　　初始条件：线性表L已存在，且 1 ≤ i ≤ ListLength(L) + 1。
		　　　操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1。
		
		ListDelete(&L, i)
		　　　初始条件：线性表L已存在且非空，且 1 ≤ i ≤ ListLength(L)。
		　　　操作结果：删除L的第i个数据元素，L的长度减1。
		
		TraverseList(L)
		　　　初始条件：线性表L已存在。
		　　　操作结果：对线性表L进行遍历，在遍历过程中对L的每个节点访问一次。
} ADT List
```

## 2.4 线性表的顺序表示和实现

### 2.4.1 线性表的顺序表示

线性表的顺序表示指的是：用一组地址连续的存储单元依次存储线性表的数据元素，也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为顺序表（Sequential List）。特点是：逻辑上相邻的数据元素，其物理位置也是相邻的。

设线性表每个元素占用 $l$个存储单元，以所占的第一个单元的存储地址作为数据元素的存储起始位置，则第 $i + 1$个数据元素的存储位置 $\mathrm{LOC}(a_{i + 1})$和第 $i$个数据元素的存储位置 $\mathrm{LOC}(a_i)$满足下列关系： $\mathrm{LOC}(a_{i + 1}) = \mathrm{LOC}(a_i) + l$。

一般来说，线性表的第 $i$个数据元素 $a_i$的存储位置为 $\mathrm{LOC}(a_i) = \mathrm{LOC}(a_1) + (i - 1) \times l$：

- 其中 $\mathrm{LOC}(a_1)$是线性表的第一个数据元素 $a_1$的存储位置，称作线性表的起始位置或基地址，
- 表中相邻的元素 $a_i$和 $a_{i + 1}$的存储位置 $\mathrm{LOC}(a_i)$和 $\mathrm{LOC}(a_{i + 1})$是相邻的。
- 每个数据元素的存储位置都和线性表的起始位置相差一个常数，这个常数和数据元素在线性表中的位序成正比。
- 只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。

高级程序设计语言中，通常使用数组来描述数据结构中的顺序存储结构。在C语言中可用动态分配的一维数组表示线性表，描述如下：

```c
// ----- 顺序表的存储结构 -----
#define MAXSIZE 100 // 顺序表可能达到的最大长度

typedef struct 
{
	ElemType *elem; // 存储空间的基地址
	int length; // 当前长度
} SqList; // 顺序表的结构类型为SqList
```

### 2.4.2 顺序表中基本操作的实现

#### 1. 初始化

#### 2. 取值

#### 3. 查找

【算法分析】
当在顺序表中查找一个数据元素时，时间主要耗费在数据的比较上，比较的次数取决于被查元素在线性表中的位置。

在查找时，为确定元素在顺序表中的位置，需和给定值进行比较的数据元素个数的期望值称为查找算法在查找成功时的平均查找长度（Average Search Length， ASL）。

假设 $p_i$是查找第i个元素的概率， $C_i$为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数，则在长度为n的线性表中，查找成功时的平均查找长度为： $\mathrm{ASL} = \sum \limits_{i = 1}^n p_i C_i$。从顺序表查找过程可见， $C_i$取决于所查元素在表中的位置。假设每个元素的查找概率相等，即： $p_i = \frac{1}{n}$，则上式可简化为 $\mathrm{ASL} = \frac{1}{n} \sum \limits_{i = 1}^n i = \frac{n + 1}{2}$，由此可见，顺序表按值查找算法的平均时间复杂度为O(n)。

#### 4. 插入

一般情况下，在第 $i (1 \leq i \leq n)$个位置插入一个元素时，需从最后一个元素即第n个元素开始，依次向后移动一个位置，直到第i个元素（共 $n - i + 1$个元素）。

【算法分析】
当在顺序表中某个位置上插入一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于插入元素的位置。

假设 $p_i$是在第 $i$个元素之前插入一个元素的概率， $E_{ins}$为在长度为 $n$的线性表中插入一个元素时所需移动元素次数的期望值（平均次数），则有 $E_{ins} = \sum \limits_{i = 1}^{n + 1} p_i (n - i + 1)$。可以假定在线性表的任何位置上插入元素都是等概率的，即 $p_i = \frac{1}{n + 1}$，则 $E_{ins} = \sum \limits_{i = 1}^{n + 1} p_i (n - i + 1)$式可简化为： $E_{ins} = \frac{1}{n + 1} \sum \limits_{i = 1}^{n + 1} (n - i + 1) = \frac{n}{2}$，由此可见，顺序表插入算法的平均时间复杂度为 $O(n)$。

#### 5. 删除

一般情况下，删除第 $i (1 \leq i \leq n)$个元素时需将第 $i + 1$个至第 $n$个元素（共 $n - i$个元素）依次向前移动一个位置（ $i = n$时无须移动）。

【算法分析】
当在顺序表中某个位置上删除一个数据元素时，其时间主要耗费在移动元素上，而移动元素的个数取决于删除元素的位置。

假设 $p_i$是删除第 $i$个元素的概率， $E_{del}$为在长度为 $n$的线性表中删除一个元素时所需移动元素次数的期望值（平均次数），则有： $E_{del} = \sum \limits_{i = 1}^{n} p_i (n - i)$。可以假定在线性表的任何位置上删除元素都是等概率的，即： $p_i = \frac{1}{n}$，则 $E_{del} = \sum \limits_{i = 1}^{n} p_i (n - i)$式可简化为： $E_{del} = \frac{1}{n} \sum \limits_{i = 1}^{n} (n - i) = \frac{n - 1}{2}$，由此可见，顺序表删除算法的平均时间复杂度为 $O(n)$。

顺序表可随机存取表中任一元素，存储位置可用一个简单、直观公式来表示。缺点：做插入或删除操作时，需移动大量元素。另外由于数组有长度相对固定的静态特性，当表中数据元素个数较多且变化较大时，操作过程相对复杂，必然导致存储空间的浪费。

## 2.5 线性表的链式表示和实现

### 2.5.1 单链表的定义和表示

线性表链式存储结构的特点：
- 用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。
- 为了表示每个数据元素 $a_i$与其直接后继数据元素 $a_{i + 1}$之间的逻辑关系，对数据元素 $a_i$来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（直接后继的存储位置）。这两部分信息组成数据元素 $a_i$的存储映像，称为节点（node）。它包括两个域：
	- 存储数据元素信息的域称为数据域；
	- 存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。
- $n$个节点（$a_i (1 \leq i \leq n)$的存储映像）链接成一个链表，即为线性表： $(a_1, a_2, \cdots, a_n)$的链式存储结构。
- 由于此链表的每个节点中只包含一个指针域，故又称线性链表或单链表。

根据链表节点所含指针个数、指针指向和指针连接方式，链表可分为：

- 单链表
- 循环链表
- 双向链表
- 二叉链表
- 十字链表
- 邻接表
- 邻接多重表

其中单链表、循环链表、双向链表多用于实现线性表的链式存储结构，其他形式多用于实现树和图等非线性结构。

用单链表表示线性表时，数据元素之间的逻辑关系是由节点中的指针指示的。指针为数据元素之间的逻辑关系的映像，逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，因此，这种存储结构为非顺序映像或链式映像。

一般情况下，为了处理方便，在单链表的第一个节点之前附设一个节点，称之为头节点。增加头节点的作用如下：

- 便于首元节点的处理：首元节点的地址保存在头节点的指针域中，对链表的第一个数据元素的操作与对其他数据元素的操作相同，无须进行特殊处理。
- 便于空表和非空表的统一处理：当链表不设头节点时，假设L为单链表的头指针，它应指向首元节点，则当单链表为长度n为0的空表时，L指针为空。增加头节点后，无论链表是否为空，头指针都是指向头节点的非空指针。

单链表是非随机存取的存储结构，要取得第i个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存储结构。

### 2.5.2 单链表基本操作的实现

#### 1. 初始化

#### 2. 取值

根据给定的位置序号i，只能从链表首元节点出发，顺着链域next逐个节点向下访问。

【算法分析】
该算法的基本操作是比较j和i并后移指针p，while循环体中的语句频度与位置i有关。若 $1 \leq i \leq n$，则频度为 $i - 1$，一定能取值成功；若 $i > n$，则频度为n，取值失败。因此算法的最坏时间复杂度为 $O(n)$。

假设每个位置上元素的取值概率相等，即： $p_i = \frac{1}{n}$，则： $\mathrm{ASL} = \frac{1}{n} \sum \limits_{i = 1}^{n} (i - 1) = \frac{n - 1}{2}$，由此可见，单链表取值算法的平均时间复杂度为 $O(n)$。

#### 3. 查找

【算法分析】
该算法的执行时间与待查找的值e相关，其平均时间复杂度分析类似于算法单链表的取值，也为 $O(n)$。

#### 4. 插入

【算法分析】
单链表的插入操作平均时间复杂度为 $O(n)$，这是因为，为了在第i个节点之前插入一个新节点，必须首先找到第 $i - 1$个节点，其时间复杂度与算法单链表的取值相同，为 $O(n)$。

#### 5. 删除

【算法分析】
类似于插入算法，删除算法时间复杂度亦为 $O(n)$。

#### 6. 创建单链表

根据节点插入位置的不同，链表的创建方法可以分为前插法和后插法。

##### （1） 前插法

前插法是通过将新节点逐个插入链表的头部（头节点之后）来创建链表。

前插法时间复杂度为 $O(n)$。

##### （2） 后插法

后插法是通过将新节点逐个插入链表的尾部来创建链表。为了使新节点能够插入表尾，需要增加一个尾指针r指向链表的尾节点。

后插法时间复杂度为 $O(n)$。

### 2.5.3 循环链表

循环链表（Circular Linked List）是另一种形式的链式存储结构。特点是表中最后一个节点的指针域指向头节点，整个链表形成一个环。从表中任一节点出发均可找到表中其他节点。类似的，还可以有多重链的循环链表。

### 2.5.4 双向链表

在单链表中，查找直接后继的执行时间为 $O(1)$，而查找直接前驱的执行时间为 $O(n)$。为克服单链表这种单向性的缺点，可利用双向链表（Double Linked List）。

在双向链表的节点中有两个指针域，一个指向直接后继，另一个指向直接前驱。