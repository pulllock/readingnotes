# 第1章 绪论

## 1.1 数据结构的研究内容

## 1.2 数据结构的基本概念和术语

### 1.2.1 数据、数据元素、数据项和数据对象

- 数据（Data）是客观事物的符号表示，是所有能输入计算机中并被计算机程序处理的符号的总称。
- 数据元素（Data Element）是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。数据元素也称为元素、记录等。数据元素用于完整地描述一个对象。
- 数据项（Data Item）是组成数据元素的、有独立含义的、不可分割的最小单位。
- 数据对象（Data Object）是性质相同的数据元素的集合，是数据的一个子集。

### 1.2.2 数据结构

数据结构（Data Structure）是相互之间存在一种或多种特定关系的数据元素的集合。

数据结构包括逻辑结构和存储结构两个层次。

#### 1. 逻辑结构

数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作从具体问题中抽象出来的数学模型。

数据的逻辑结构有两个要素：

- 数据元素
- 关系，是指数据元素之间的逻辑关系。

数据的逻辑结构通常有4类基本逻辑结构：

- 集合结构：数据元素之间除了“属于同一集合”的关系外，别无其他关系。
- 线性结构：数据元素之间存在一对一的关系。
- 树结构：数据元素之间存在一对多的关系。
- 图结构（或网状结构）：数据元素之间存在多对多的关系。

集合结构、树结构、图结构（或网状结构）都属于非线性结构。

线性结构包括：

- 线性表
- 栈和队列
- 字符串
- 数组
- 广义表

非线性结构包括：

- 树结构：
	- 树：具有多个分支的层次结构
	- 二叉树：具有两个分支的层次结构
- 图结构：
	- 有向图
	- 无向图
- 集合结构

#### 2. 存储结构

数据对象在计算机中的存储表示称为数据的存储结构，也称为物理结构。数据元素在计算机中有两种基本的存储结构：

- 顺序存储结构：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。
- 链式存储结构：顺序存储结构要求所有元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。为了表示节点之间的关系，需要给每个节点附加指针字段，用于存放后继元素的存储地址。链式存储结构通常借助于程序设计语言的指针类型来描述。

### 1.2.3 数据类型和抽象数据类型

#### 1. 数据类型

数据类型（Data Type）是一个值的集合和定义在这个值集上的一组操作的总称。

#### 2. 抽象数据类型

抽象数据类型（Abstract Data Type， ADT）一般指由用户定义的、表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括3个部分：数据对象、数据对象上关系的集合以及数据对象的基本操作的集合。

抽象数据类型的定义格式如下：

```c
ADT 抽象数据类型名 {
	数据对象: <数据对象的定义>
	数据关系: <数据关系的定义>
	基本操作: <基本操作的定义>
} ADT 抽象数据类型名
```

其中，数据对象和数据关系的定义采用数学符号和自然语言描述，基本操作的定义格式为：

```c
基本操作名(参数表)
	初始条件: <初始条件描述>
	操作结果: <操作结果描述>
```

- 基本操作有两种参数：
	- 赋值参数：只为操作提供输入值；
	- 引用参数：以&打头，除可提供输入值外，还将返回操作结果。
- 初始条件：描述了操作执行之前数据结构和参数应满足的条件，若初始条件为空，则省略。
- 操作结果：说明了操作正常完成之后，数据结构的变化状况和应返回的结果。

## 1.3 抽象数据类型的表示与实现

（1）预定义常量及类型：

```c
// 函数结果状态码
#define OK 1
#define ERROR 0
#define OVERFLOW -2

// Status是函数返回值类型，其值是函数结果状态代码。
typedef int Status;
```

（2）数据结构的表示（存储结构）用类型定义（typedef）描述；数据元素类型约定为ElemType，由用户在使用该数据类型时自行定义。
（3）基本操作的算法用如下格式的函数来描述：

```c
函数类型 函数名(函数参数表)
{
	// 算法说明
	语句序列
} // 函数名
```

当函数返回值为函数结果状态代码时，函数定义为Status类型。在形参中，以&打头的参数为引用参数。
（4）内存的动态分配与释放，使用new和delete动态分配和释放内存空间：

- 分配空间： `指针变量 = new 数据类型;`
- 释放空间： `delete 指针变量;`

（5）赋值语句：

- 简单赋值： `变量名 = 表达式;`
- 串联赋值： `变量名1 = 变量名2 = ... = 变量名n = 表达式;`
- 成组赋值： `(变量名1, ..., 变量名n) = (表达式1, ..., 表达式n);`
- 结构赋值： `结构名1 = 结构名2;`、 `结构名 = (值1, 值2, ..., 值n);`
- 条件赋值： `变量名 = 条件表达式 ? 表达式T : 表达式F;`
- 交换赋值： `变量名1 <--> 变量名2;`

（6）选择语句：

- 条件语句1： `if (表达式) 语句;`
- 条件语句2：
```c
if (表达式) 语句;
else 语句;
```
- 开关语句：
```c
switch (表达式)
{
	case 值1: 语句序列1; break;
	case 值2: 语句序列2; break;
	...
	case 值n: 语句序列n; break;
	default: 语句序列n+1;
}
```

（7）循环语句：

- for语句： `for (表达式1; 条件; 表达式2) 语句;`
- while语句： `while (条件) 语句;`
- do-while语句：
```c
do {
	语句序列;
} while (条件);
```

（8）结束语句：

- 函数结束语句：
	- `return 表达式;`
	- `return;`
	- case或循环结束语句 `break;`
	- 异常结束语句 `exit (异常代码);`

（9）输入输出语句使用C++流式输入输出的形式：

- 输入语句： `cin >> 变量1 >> ... >> 变量n;`
- 输出语句： `cout << 表达式1 << ... << 表达式n;`

（10）基本函数：

- 求最大值： `Max (表达式1, ..., 表达式n)`
- 求最小值： `Min (表达式1, ..., 表达式n)`

## 1.4 算法和算法分析

### 1.4.1 算法的定义及特性

算法（Algorithm）是为了解决某类问题而规定的一个有限长的操作序列。

一个算法必须满足以下5各重要特性：

- 有穷性：一个算法必须总是在执行有穷步后结束，且每一步都必须在有穷时间内完成。
- 确定性：对于每种情况下所应执行的操作，在算法中都有确切的规定，不会产生二义性，算法的执行者或阅读者都能明确其含义及如何执行。
- 可行性：算法中的所有操作都可以通过将已经实现的基本操作运算执行有限次来实现。
- 输入：一个算法有0个或多个输入。
- 输出：一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。

### 1.4.2 评价算法优劣的基本标准

- 正确性
- 可读性
- 健壮性
- 高效性：高效性包括时间和空间两个方面。时间高效是指算法设计合理，执行效率高，可以用时间复杂度来度量；空间高效是指算法占用存储容量合理，可以用空间复杂度来度量。

### 1.4.3 算法的时间复杂度

衡量算法效率的方法主要有两类：

- 事后统计法
- 事前分析估算法

#### 1. 问题规模和语句频度

问题规模，是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示。n越大算法的执行时间越长。

一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句重复执行次数和执行一次所需时间的乘积。

一条语句的重复执行次数称作语句频度（Frequency Count）。

设每条语句执行依次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量。

#### 2. 算法的时间复杂度定义

用O表示数量级。

一般情况下，算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作： T(n) = O(f(n))，它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度（Time Complexity）。

数学符号O的严格定义为：若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)=O(f(n))表示存在正的常数C和 $n_0$，使得当 $n \geq n_0$时都满足 $0 \leq T(n) \leq Cf(n)$。

该定义说明了函数T(n)和f(n)具有相同的增长趋势，并且T(n)的增长至多趋向于函数f(n)的增长。符号O用来描述增长率的上限，它表示当问题规模 $n > n_0$时，算法的执行时间不会超过f(n)。

#### 3. 算法的时间复杂度分析举例

分析算法时间复杂度的基本方法为：找出所有语句中语句频度最大的那条语句作为基本语句，计算基本语句的频度得到问题规模n的某个函数f(n)，取其数量级用符号O表示即可。

**定义1.1** 若 $f(n) = a_m n^m + a_{m - 1} n^{m - 1} + \cdots + a_1 n + a_0$是一个m次多项式，则 $T(n)=O(n^m)$。

- 算法的执行时间是一个与问题规模n无关的常数，算法的时间复杂度为T(n)=O(1)，称为常量阶。
	- 如果算法的执行时间不随问题规模n的增长而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是O(1)。
- 算法的时间复杂度为T(n)=O(n)，称为线性阶。
- 算法的时间复杂度为 $T(n) = O(n^2)$，称为平方阶。
- 算法的时间复杂度为 $T(n) = O(n^3)$，称为立方阶。
- 算法的时间复杂度为 $T(n) = O(\log_2n)$，称为对数阶。

常见的时间复杂度按数量级递增排列依次为：

- 常量阶O(1)，
- 对数阶 $O(\log_2n)$，
- 线性阶O(n)，
- 线性对数阶 $O(n \log_2n)$，
- 平方阶 $O(n^2)$，
- 立方阶 $O(n^3)$，
- $\cdots \cdots$，
- k次方阶 $O(n^k)$，
- 指数阶 $O(2^n)$。

#### 4. 最好、最坏和平均时间复杂度

- 算法在最好情况下的时间复杂度为最好时间复杂度，是指算法计算量可能达到的最小值；
- 算法在最坏情况下的时间复杂度为最坏时间复杂度，是指算法计算量可能达到的最大值；
- 算法的平均时间复杂度是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。

### 1.4.4 算法的空间复杂度

采用渐进空间复杂度（Space Complexity）作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n的函数，记作S(n)=O(f(n))。

若算法执行时所需要的辅助空间相对于输入数据量而言是个常数，则称这个算法在原地工作，辅助空间为O(1)。

## 1.5 小结

# 第2章 线性表

## 2.1 线性表的定义和特点

由 $n (n \geq 0)$个数据特性相同的元素构成的有限序列，称为线性表。

线性表中元素的个数 $n (n \geq 0)$定义为线性表的长度，当n=0时称之为空表。

对于非空的线性表或线性结构，特点是：

- 存在唯一的一个被称作“第一个”的数据元素；
- 存在唯一的一个被称作“最后一个”的数据元素；
- 除第一个元素之外，结构中的每个数据元素均只有一个前驱；
- 除最后一个元素之外，结构中的每个数据元素均只有一个后继。

## 2.2 案例引入

