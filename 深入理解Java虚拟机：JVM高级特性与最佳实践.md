# 深入理解Java虚拟机：JVM高级特性与最佳实践

# Java内存区域与内存溢出异常
## 运行时数据区域

1. 程序计数器
2. Java虚拟机栈
3. 本地方法栈
4. Java堆
5. 方法区
6. 运行时常量池

### 程序计数器
当前线程所执行的字节码的行号指示器.每条线程都需要有一个独立的程序计数器.

执行的是java方法,计数器记录的是正在执行的虚拟机字节码指令的地址.执行的是Native方法,计数器值为空.

此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域.

### Java虚拟机栈
Java虚拟机栈也是线程私有的,生命周期与线程相同.

Java方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表,操作栈,动态链接,方法出口等信息.

方法被调用到执行完就对应一个栈帧在虚拟机栈中从入栈到出栈的过程.

局部变量表存放编译期可知的基本数据类型,对象引用和returnAddress类型

局部变量表所需内存空间在编译期完成分配.

如果线程请求的栈深度大于虚拟机允许的深度,将抛出StackOverflowError异常;如果虚拟机栈可以动态扩展,当扩展时无法申请到足够内存时,会抛OutOfMemoryError异常.

### 本地方法栈
虚拟机栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的native方法服务.

SunHotSpot虚拟机把本地方法栈和虚拟机栈合二为一.

本地方法栈也会抛StackOverflowError和OutOfMemoryError异常.

### java堆
被所有线程共享,虚拟机启动时创建.存放对象实例.

所有的对象实例以及数组都要在堆上分配.

新生代和老年代

Eden空间,From Survivor空间,To Survivor空间

物理上不连续的内存空间,只要逻辑上是连续的即可.

堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOfMemoryError异常.

### 方法区
方法区和Java堆一样,是各个线程共享的内存区域,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据.

很多人把方法区称为永久代

垃圾收集行为在这个区域是比较少见的.这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载.

### 运行时常量池
运行时常量池是方法区的一部分. 用于存放编译器生成的各种字面量和符号引用,这部分内容将在类加载后存放到方法区的运行时常量池中.

### 对象的访问

使用句柄

直接指针

# 垃圾收集器与内存分配策略

## 对象已死?

* 引用计数算法
	
	很难解决对象间的相互循环引用问题
	
* 根搜索算法

### 回收方法区
永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类

## 垃圾收集算法

1. 标记-清除算法
	
	缺点:效率问题和空间问题
2. 复制算法

	它将可用内存按容量化为大小相等的两块,每次只使用一块,当这一块用完了,就将还存活的对象复制到另外一块,再把已使用的一次清理掉.
	
	回收新生代
	
	将内存分为一块较大的Eden空间和两块较小的Survivor空间,每次使用Eden和其中的一块Survivor,回收时将Eden和Survivor中还存活着的对象一次性的拷贝到另外一块Survivor空间上,最后清理掉Eden和刚用过的Survivor空间
	
	HotSpot虚拟机默认Eden和Survivor比例是8:1
	
3. 标记-整理算法
	
	让所有存活的对象都向一端移动,然后直接清理掉端边界以外的内存
4. 分代收集算法
	
	

## 垃圾收集器
1. Serial收集器
	* 新生代
	* 单线程收集器
	* 必须暂停其他的工作线程
	* 简单而高效
	* 运行在Client模式下的默认新生代收集器
2. ParNew收集器
	* 是Serial收集器的多线程版本,使用多线程进行垃圾收集
	* 新生代收集器
	* 运行在Server模式下的虚拟机中首选的新生代收集器
	* 除了Serial收集器之外,目前只有它能与CMS收集器配合
3. Parallel Scavenge收集器
	* 新生代收集器,使用复制算法
	* 并行多线程收集器
	* 目标是达到一个可控制的吞吐量
	* 主要适合在后台运算而不需要太多交互的任务
	* -XX:MaxGCPauseMills 控制最大垃圾收集停顿时间
	* -XX:GCTimeRatio 设置吞吐量大小
	* -XX:+UseAdptiveSizePolicy 打开,可以自适应调节策略
4. Serial Old收集器
	* Serial收集器的老年代版本
	* 单线程收集器
	* 标记-整理算法
	* Cliet模式下虚拟机使用
	* Server模式下,在JDK1.5以及之前版本中与Parallel Scavenge收集器搭配使用,另一个就是作为CMS收集器的后备预案
5. Parallel Old收集器
	* Parallel Scavenge收集器的老年代版本
	* 使用多线程和标记-整理算法
6. CMS(Concurrent Mark Sweep)收集器
	* 以获取最短回收停顿时间为目标的收集器
	* 	标记-清除算法实现
	*  运作过程:
		+ 初始标记
		+ 并发标记
		+ 重新标记
		+ 并发清除
	* 并发收集,低停顿
	* 缺点:
		+ 对CPU资源非常敏感
		+ 无法处理浮动垃圾(Floating Garbage)
		+ 标记-清除算法,会产生大量空间碎片
7. G1收集器(Garbage First)
	* 并行与并发
	* 分代收集
	* 空间整合z
	* 可预测的停顿
	* 运作步骤:
		+ 初始标记
		+ 并发标记
		+ 最终标记
		+ 筛选回收
8. Minor GC和Full GC
	* Minor GC 新生代GC,频繁,速度快
	* Major GC/Full GC 老年代GC,速度慢

9. 大对象直接进入老年代
	* 大对象是指需要大量连续内存空间的Java对象.
	* -XX:PretenureSizeThreshold 大于这个值得对象直接进入老年代分配,只对Serial和ParNew两款收集器有效
10. 长期存活对象进入老年代
	* 对象年龄(Age)计数器
	* 年龄增加到一定程度(默认15)时,被晋升到老年代
	* -XX:MaxTenuringThreshold来设置
11. 动态对象年龄判定
	* Surviver空间中相同年龄所有对象大小的总和大于Surviver空间的一半,年龄大于或等于该年龄的对象直接进入老年代,无需等到MaxTenuringThreshold要求的年龄

# 虚拟机性能监控
	1. jps 显示所有HotSpot虚拟机进程
	2. jstat 收集HotSpot虚拟机各方面运行数据
	3. jinfo 显示虚拟机配置信息
	4. jmap 生成虚拟机的内存转储快照
	5. jhat 分析heapdump文件
	6. jstack 显示虚拟机线程快照
## jps 虚拟机进程状况工具
可以列出正在运行的虚拟机进程,显示虚拟机执行主类名称,显示进程的本地虚拟机唯一ID(LVMID).

本地虚拟机进程LVMID与系统进程ID(PID)是一致的.

jps命令格式:

```
jps [options] [hostid]
```
options:

* -q 只输出LVMID,不显示主类名
* -m 输出虚拟机进程启动时传递给main()的参数
* -l 输出主类全名或者jar路径
* -v 输出虚拟机进程启动时JVM参数

## jstat 虚拟机统计信息监视工具
监视各种运行状态信息,显示本地或远程虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据

jstat命令格式:

```
jstat [option vmid [interval[s|ms] [count]]]

```
* VMID 如果是本地虚拟机进程,VMID与LVMID是一致的,如果是远程虚拟机,VMID格式是:[protocal:][//]lvmid[@hostname[:port]/servername]
* interval和count 查询间隔和次数
* options:
	+ -class 监视类装载,卸载数量,总空间,类装载耗费时间
	+ -gc 监视java堆情况,包括Eden区,2个survivor区,老年代,永久代的容量,已用空间,GC时间合计
	+ -gccapacity 与-gc基本相同,主要关注堆各个区域使用到的最大和最小空间
	+ -gcutil 与-gc基本相同,主要关注已使用空间占总空间的百分比
	+ -gccause 与-gcutil一样,额外输出导致上一次GC产生的原因
	+ -gcnew 监视新生代GC情况
	+ -gcnewcapacity 与-gcnew基本相同,主要关注使用到的最大和最小空间
	+ -gcold 监视老年代GC情况
	+ -gcoldcapacity 与-gcold基本相同,主要关注使用到的最大和最小空间
	+ -gcpermcapacity 永久代使用的最大和最小空间
	+ -compiler 输出JIT编译器编译过的方法,耗时等信息
	+ printcompilation 输出已被JIT编译的方法

## jinfo 配置信息工具
实时查看和调整虚拟机的参数
jinfo命令格式:

```
jinfo [option] pid
```

## jmap 内存映像工具
生成堆转储快照(heapdump)

查询finalize执行队列,java堆和永久代的详细信息,如空间使用率,当前用的哪种收集器

jmap命令格式:

```
jmap [option] vmid
```

option

* -dump 生成java堆转储快照,格式:-dump:[live,]format=b,file=<filename>
* -finalizerinfo 显示在F-Queue中等待Finalizer线程执行finalize方法的对象
* -heap 显示堆详细信息
* -histo 显示堆中对象统计信息,包括类,实例数量,合计容量
* -permstat 以ClassLoader为统计口径显示永久代内存状态
* -F 强制生成dump快照

## jhat 虚拟机堆转储快照分析工具
分析jmap生成的堆转储快照

## jstack 堆栈跟踪工具
生成虚拟机当前时刻的线程快照.

线程快照:当前虚拟机内每一条线程正在执行的方法堆栈集合.

目的主要是定位线程出现长时间停顿的原因.

jstack命令格式:

```
jstack [option] vmid
```

option:
* -F 强制输出线程堆栈
* -l 除堆栈外,显示关于锁的附加信息
* -m 如果调用到本地方法,显示c/c++的堆栈

# JDK可视化工具

## JConsole java监视与管理控制台

### 概述标签

### 内存监控
相当于可视化的jstat命令,监视受收集器管理的虚拟机内存(Java堆和永久代)的变化趋势

### 线程监控
相当于可视化的jstack命令

## VisualVM 多合一故障处理工具

### BTrace动态日志跟踪插件



# 虚拟机类加载机制

## 类加载时机
* 加载
* 验证
* 准备
* 解析
* 初始化
* 使用
* 卸载

## 类加载的过程

### 加载
1. 通过类的全限定名获取定义此类的二进制字节流
2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构
3. 在java堆中生成一个代表这个类的java.lang.Class对象,作为方法区这些数据的访问入口

+ ZIP包读取,JAR,EAR,WAR
+ 网络读取,Applet
+ 动态代理
+ 其他文件,JSP
+ 数据库
+ ...

### 验证
1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

### 准备
正式为类变量分配内存并设置类变量初始值,这些内存将在方法区中进行分配

### 解析
虚拟机将常量池内的符号引用替换为直接引用

* 符号引用
	
	符号引用以一组符号来描述所引用目标,可以是任何形式的字面量.符号引用与虚拟机实现的内存布局无关,引用目标不一定已经加载到内存中
	
* 直接引用
	
	直接引用可以是直接指向目标的指针,相对偏移量或是一个能间接定位到目标的句柄.直接引用是与虚拟机实现的内存布局相关的,同一个符号引用在不用虚拟机实例上翻译出来的直接引用一般不会相同.如有直接引用,那引用的目标必定已经存在内存中.

1. 类或接口的解析
2. 字段解析
3. 类方法解析
4. 接口方法解析

### 初始化
初始化阶段是执行类构造器\<clinit>()方法的过程

* \<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的,编译器收集的顺序是由语句在源文件中出现的顺序所决定的,静态语句块中只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句块中可以赋值,但不能访问.
* \<clinit>()方法与类的构造函数不同,它不需要显式的调用父类构造器,虚拟机会保证子类的\<clinit>()方法执行之前,父类的\<clinit>()已经执行完毕.因此在虚拟机中第一个被执行的\<clinit>()方法的类肯定是java.lang.Object.
* 由于父类的\<clinit>()方法先执行,也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作.
* \<clinit>()方法对于类或接口来说并不是必须的,一个类中没有静态语句块,也没有对变量的赋值操作,编译器可以不为这个类生成\<clinit>()方法.
* 接口中不能使用静态语句块,但是有变量初始化赋值操作,因此接口与类一样都会生成\<clinit>()方法.接口与类不同,执行接口的\<clinit>()方法不需要先执行父接口的\<clinit>()方法,只有当父类接口中定义的变量被使用时,父接口才会被初始化.接口的实现类在初始化时也一样不会执行接口的\<clinit>()方法.
* 虚拟机会保证一个类的\<clinit>()方法在多线程中被正确的加锁和同步.阻塞!

# 类加载器
* 启动类加载器
	
	加载<JAVA_HOME>\lib中的或者被-Xbootclasspath所指定路径的,并且是虚拟机是别的,仅按照文件名,如rt.jar
	
* 扩展类加载器
	
	加载<JAVA_HOME>\lib\ext中的或者被java.ext.dirs系统变量所指定的类库,开发者可直接使用扩展加载器

* 应用程序类加载器
	
	也称为系统类加载器,加载用户类路径(ClassPath)上指定的类库,开发者可以直接使用这个类加载器
	

# 虚拟机字节码执行引擎
## 运行时栈帧结构
栈帧用于支持虚拟机进行方法调用和方法执行的数据结构是虚拟机运行时数据区中的虚拟机栈的栈元素.存储了方法的局部变量表,操作数栈,动态连接和方法返回地址等信息.

### 局部变量表
存放方法参数和方法内部定义的局部变量

### 操作数栈
LIFO栈

### 动态连接

### 方法返回地址

#### 附加信息

## 方法调用
确定被调用方法的版本(即调用哪一个方法)

### 解析
所有方法调用中的目标方法在Class文件里都是一个常量池中的符号引用,在类加载的解析阶段,会将其中一部分符号引用转化为直接引用.

符合"编译期可知,运行期不可变"的方法主要有静态方法和私有方法.

### 分派
分派调用过程将揭示多态性特征的一些最基本的体现,如重载和重写.

1. 静态分派
	
	所有依赖静态类型来定位方法执行版本的分派动作,都称为静态分派.静态分派的典型应用就是方法重载.
	
	静态分派发生在编译阶段.

2. 动态分派
	
	重写
	
	运行期根据实际类型确定方法执行版本的分派工程称为动态分派

