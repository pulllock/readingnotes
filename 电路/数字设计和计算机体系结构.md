# 第1章 二进制

## 1.3 数字抽象

大部分物理变量是连续的。例如：电线上的电压、震动的频率、物体的位置等都是连续值。相反，数字系统使用离散值变量（discrete-valued variable）来表示信息，也就是说变量是有限数目的不同离散值。

大部分电子计算机使用二进制（2个值）表示，高电压表示1，低电压表示0。

一个有N个不同状态的离散值变量的信息量（amount of information）D由位（bit，或称比特）度量，N和D之间的关系是：

$$
D=log_2N位
$$

一个二进制状态变量包含 $log_22=1$位的信息。

位是二进制数字（binary digit）的缩写。

George Boole发明了一种针对二进制变量进行逻辑操作的系统，称为布尔逻辑（Boolean logic）。每个布尔变量都是TRUE或FALSE。电子计算机普遍使用正电压表示1，使用0电压表示0。

## 1.4 数制

### 1.4.1 十进制数

十进制（decimal）是由0，1，2，...，9这10个数字组成。

在十进制数中，每一列的权都是前一列的10倍。从右到左，每一列的权分别为1、10、100、1000等。

十进制数的基（base）为10。基通过数值后方的下表表示，以避免与原数值混淆。

如：十进制数 $9742_{10}$的表示：

$$
9742_{10}=9 \times 10^3 + 7 \times 10^2 + 4 \times 10^1 + 2 \times 10^0
$$

一个N位的十进制数表示 $10^N$个数字中的某一个：0，1，2，3，...， $10^N-1$，称为数的表示范围（range）。

例如：一个3位的十进制数表示了从0～999的1000个数字中的某一个。

### 1.4.2 二进制数

1位表示0和1两个值中的一个。将多位合并在一起就形成了一个二进制数（binary number）。

二进制数的每一列的权都是前一列的2倍，因此二进制数的基是2。

在二进制数中，每一列的权（从右到左）分别为：1，2，4，8，16，32，64，128，256，512，1024，2048，4096，8192，16384，32768，65536，以此类推。 $2^n(n \leq16)$。

一个N位二进制数代表 $2^N$个数字中的某一个：0，1，2，3，...， $2^N-1$。

二进制数和与之相等的十进制数：

| 1位二进制数 | 2位二进制数 | 3位二进制数 | 4位二进制数 | 十进制等价值 |
| ------ | ------ | ------ | ------ | ------ |
| 0      | 00     | 000    | 0000   | 0      |
| 1      | 01     | 001    | 0001   | 1      |
|        | 10     | 010    | 0010   | 2      |
|        | 11     | 011    | 0011   | 3      |
|        |        | 100    | 0100   | 4      |
|        |        | 101    | 0101   | 5      |
|        |        | 110    | 0110   | 6      |
|        |        | 111    | 0111   | 7      |
|        |        |        | 1000   | 8      |
|        |        |        | 1001   | 9      |
|        |        |        | 1010   | 10     |
|        |        |        | 1011   | 11     |
|        |        |        | 1100   | 12     |
|        |        |        | 1101   | 13     |
|        |        |        | 1110   | 14     |
|        |        |        | 1111   | 15     |

例，二进制转换为十进制

将二进制数 $10110_2$转换为十进制

解：

$$
10110_2 = 1 \times 2^4 + 0 \times 2^3 + 1 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 22_{10}
$$

例，十进制转换为二进制

将十进制数 $84_{10}$转换为二进制

解：

需要判断每一列的二进制数值是1还是0。从二进制数的最左或最右边都可以进行。

从左开始：

- 首先从小于给定十进制数的2的最高次幂开始， $84 \geq 64$，因此权为64的这一列是1，还剩 84 - 64 = 20。

- 20 < 32，所以权为32的这一列是0。

- $20 \geq 16$，所以权为16的这一列是1，剩下20 - 16 = 4。

- 4 < 8，所以权为8的这一列是0，

- $4 \geq 4$，因此权为4的这一列为1，剩下4 - 4 = 0。

- 因此权为2和1的列的二进制数值均为0。

- 将它们组合在一起， $84_{10} = 1010100_2$。

从右开始：

- 用2重复除给定的十进制数，余数放在每一列中。

- 84 / 2 = 42，因此权为1的这一列为0。

- 42 / 2 = 21，因此权为2的这一列为0。

- 21 / 2 = 10，余数是1，因此权为4的这一列为1。

- 10 / 2 = 5，权为8的这一列为0。

- 5 / 2 = 2，余数是1，权为16的这一列为1。

- 2 / 2 = 1，权为32的这一列为0。

- 1 / 2 = 0，余数是1，权为64的这一列为1。

- 从而 $84_{10} = 1010100_2$

### 1.4.3 十六进制数

书写一位很大的二进制数将十分冗长且易于出错。4位一组的二进制数可表示 $2^4 = 16$种数。因此，有时使用基数为16的表示会更方便，这称为十六进制（hexadecimal）。

十六进制数使用数字0～9和字母A～F。十六进制的每一列的权分别是1，16， $16^2 (256)$， $16^3 (4096)$，以此类推。

十六进制：

| 十六进制 | 十进制等价值 | 二进制等价值 |
| ---- | ------ | ------ |
| 0    | 0      | 0000   |
| 1    | 1      | 0001   |
| 2    | 2      | 0010   |
| 3    | 3      | 0011   |
| 4    | 4      | 0100   |
| 5    | 5      | 0101   |
| 6    | 6      | 0110   |
| 7    | 7      | 0111   |
| 8    | 8      | 1000   |
| 9    | 9      | 1001   |
| A    | 10     | 1010   |
| B    | 11     | 1011   |
| C    | 12     | 1100   |
| D    | 13     | 1101   |
| E    | 14     | 1110   |
| F    | 15     | 1111   |

例，十六机制转换为二进制和十进制

将十六进制数 $2ED_{16}$转换为二进制和十进制

解：

十六进制和二进制之间的转换很容易，其中每个十六进制数字相当于4位二进制数字：

- $2_{16} = 0010_2$

- $E_{16} = 1110_2$

- $D_{16} = 1101_2$

- 因此 $2ED_{16} = 001011101101_2$

十六进制转换为十进制需要计算：

$$
2ED_{16} = 2 \times 16^2 + E \times 16^1 + D \times 16^0 = 749_{10}
$$

例，二进制转换为十六进制

将二进制数 $1111010_2$转换为十六进制

解：

- 从右往左读取数据，

- 4个最低位是 $1010_2 = A_{16}$，

- 下面是 $111_2 = 7_{16}$。

- 因此 $1111010_2 = 7A_{16}$。

例，十进制转换为十六进制和二进制

将十进制数 $333_{10}$转换为十六进制和二进制

解：

十进制转换为十六进制可以从左或从右进行。

从左开始：

- 从小于给定十进制数的16的最高次幂开始， 333中仅包含了一个256，所以在权为256的这一列是1，还剩333 - 256 = 77。

- 77中有4个16，所以在权为16的这一列是4，还剩 $77 - 16 \times 4 = 13$。

- $13_{10} = D_{16}$，所以在权为1的这一列是D。

- 因此， $333_{10} = 14D_{16}$。

从右开始：

- 用16重复除以给定的十进制数，余数放在每一列中。

- 333 / 16 = 20，余数是 $13_{10} = D_{16}$，所以权为1的这一列为D。

- 20 / 16 = 1，余数是4，所以权为16的这一列为4。

- 1 / 16 = 0，余数是1，所以权为256的这一列为1。

- 结果为 $14D_{16}$。

### 1.4.4 字节、半字节、全字

- 8位的一组称为字节（byte），能表示 $2^8 = 256$个数字。在计算机内存中存储数据习惯于用字节作单位，而不用位。

- 4位的一组或半个字节称为半字节（nibble），能表示 $2^4 = 16$个数字。一个十六进制数占用1个半字节，两个十六进制数占用一个字节。

- 微处理器处理的一块数据称为字（word），字的大小取决于微处理器的结构。

在一组位中，权为1的那位称为最低有效位（least significant bit，lsb），处于另一端的位称为最高有效位（most significant bit，msb）。

对一个字节来说，也可用最低有效字节（Least Significant Byte，LSB）和最高有效位（Most Significant Byte，MSB）来表示。

$2^{10} = 1024 \approx 10^3$。因此kilo（希腊文的千）表示 $2^{10}$。例如：

- $2^{10}$字节是1千字节（1KB）

- 兆（百万）表示 $2^{20} \approx 10^6$

- 吉（十亿）表示 $2^{30} \approx 10^9$

1024字节称为1千字节（kilobyte，KB）。1024位称为1千比特（kilobit，Kb或Kbit）。

- MB：兆字节

- Mb：兆比特

- GB：吉字节

- Gb：吉比特

内存容量经常用字节做单位，信息传输速率一般用比特/秒做单位。

### 1.4.5 二进制加法

在十进制加法中，如果两个数据之和大于单个数字所能表示的值，则将在下一列的位置上标记1。

例如，十进制加法：

```
    11
   4277
 + 5499
--------
   9776
```

最右端的一列，7 + 9 = 16，因为16 > 9，所以不能用单个数字表示，因此记录权为1的列结果（6），然后将权为10的列结果（1）进位到更高的一列中。

在二进制加法中，如果两个数相加之和大于1，那么将此按二进制进位到更高的一列。

例如，二进制加法：

```
   11
  1011
+ 0011
-------
  1110
```

在最右端一列： $1 + 1 = 2_{10} = 10_2$，使用1个二进制位无法表示此结果，因此记录此和中权为1的列结果（0），并将权为2的列结果（1）进位到更高的一列。在加法的第二列中： $1 + 1 + 1 = 3_{10} = 11_{2}$，记录此和的权为1的列结果（1），将权为2的列结果（1）进位到更高的一列。

进位到相邻列的位称为进位（carry bit）。

数字系统常常对固定长度的数字进行操作。如果加法的结果太大，超出了数字的表示范围，那么将产生溢出（overflow）。

例如，一个4位数的表示范围是[0, 15]。如果两个4位数相加的结果超过了15，那么就产生溢出。结果的第5位被抛弃，从而产生一个不正确的结果。可以通过检查最高一列是否有进位来判断是否溢出。

### 1.4.6 有符号的二进制数

有多种方案可以表示有符号（signed）二进制数，最常用的两种为：带符号的原码和补码。

#### 带符号的原码

带符号的原码（sign/magnitude）是一种直观的数据表示方式，符合我们写负数的习惯，把负号标在数字前面。

在一个N位带符号的原码数中最高位为符号位，剩下的N-1位为数值（绝对值）。符号位为0表示正数，1表示负数。

普通的二进制加法无法在带符号的原码下实现。

N位带符号的原码的数据表示范围是 $[-2^{N-1} + 1, 2^{N-1} - 1]$。这种格式在表示0时有两种：+0和-0。同一个数字有两种不同的表示方法可能会造成麻烦。

#### 二进制补码

二进制补码中最高位的权是 $-2^{N-1}$而不是 $2^{N-1}$，其他位的表示方法与无符号二进制数相同。它克服了带符号的原码格式中0有两种表示方式的缺点。在二进制补码中，0只有一种表示方式，而且可使用普通的加法。

在二进制补码中：

- 0表示成 $00...000_2$

- 正数的最高位为0： $01...111_2 = 2^{N-1} - 1$

- 负数的最高位是1： $10...000_2 = -2^{N-1}$

- -1表示成 $11...111_2$

求二进制补码的过程中，二进制补码的符号位保持不变。在此过程中，首先对数据的每一位取反，然后在数据的最低位加1。

例，负数的二进制补码表示

把 $-2_{10}$表示成一个4位的二进制补码数：

- $+2_{10} = 0010_2$，为了得到 $-2_{10}$的值，将所有位取反后加1。

- $0010_2$取反后为 $1101_2$， $1101_2 + 1 = 1110_2$，

- 所以： $-2_{10} = 1110_2$

例，二进制补码的负数的值

求二进制补码数据 $1001_2$的十进制数值：

- $1001_2$的最高位是1，所以它是负数。

- 为了求他的值，将所有位取反然后加1。

- $1001_2$取反后的结果是 $0110_2$，

- $0110_2 + 1 = 0111_2 = 7_{10}$，

- 所以 $1001_2 = -7_{10}$

用二进制补码表示的数据有个优点，加法对正数和负数都可以得出正确的结果。当进行N位的数据加法时，第N位的进位（即第N+1位结果）被丢弃。

例如，两个二进制补码数据相加

使用补码计算：

- $-2_{10} + 1_{10} = 1110_2 + 0001_2 = 1111_2 = -1_{10}$

- $-7_{10} + 7_{10} = 1001_2 + 0111_2 = 10000_2$，第5位被丢弃，剩下后4位的结果 $0000_2$

减法是将第二个操作数改变符号后求取补码，然后与第一个操作数相加来完成。

例，两个二进制补码数据相减

使用补码计算 $5_{10} - 3_{10}$：

- $3_{10} = 0011_2$，取二进制补码得 $-3_{10} = 1101_2$

- $5_{10} = 0101_2$

- 计算 $5_{10} + (-3_{10}) = 0101_2 + 1101_2 = 0010_2 = 2_{10}$

- 因为使用4位表示结果，所以最高位的进位被丢弃

使用补码计算 $3_{10} - 5_{10}$：

- 第二个操作数 $5_{10}$取补码得 $-5_{10} = 1011_2$

- 计算 $3_{10} + (-5_{10}) = 0011_2 + 1011_2 = 1110_2 = -2_{10}$

计算0的二进制补码时，需要将所有的二进制位取反（产生 $11..111_2$），然后加1，丢弃最高位，剩余 $00...000_2$。因此，0的表示是唯一的。与带符号的原码系统不同，在二进制补码表示方法中没有-0。0被认为是正数，因为它的符号位为0。

与无符号数一样，N位二进制补码数能够表示 $2^N$个可能的值。但是，这些值分为正数和负数。例如：

- 一个4位的无符号数可以表示16个数值：0～15

- 一个4位的有符号数可以表示16个数值：-8～7

N位二进制补码的表示范围是 $[-2^{N-1}, 2^{N-1} - 1]$，负数比整数多一个，因为没有-0。

最小的负数是 $10...000_2 = -2^{N-1}$，这个数有时叫做怪异数（weird number）。求取它的二进制补码时，首先各位取反变成 $01...111_2$，然后加1，变成 $10...000_2$，与原数相同。因此这个负数没有与之对应的正数。

两个N位整数或者负数相加，如果结果大于 $2^{N-1} - 1$或者小于 $-2^{N-1}$，则会产生溢出。一个正数和一个负数相加肯定不会导致溢出。

无符号整数加法中，最高位产生进位表示溢出。

在二进制补码加法中，判定溢出的条件是：如果相加两个数的符号相同且结果的符号与被加数的符号相反，则表示发生溢出。

例，有溢出的二进制数加法

用4位二进制数计算 $4_{10} + 5_{10}$。判断结果是否有溢出。

解：

- $4_{10} + 5_{10} = 0100_2 + 0101_2 = 1001_2 = -7_{10}$

- 结果超过了4位二进制补码整数的表示范围，产生了不正确的负值结果。

- 如果计算使用5位或更多位数，则结果为正确的值 $01001_2 = 9_{10}$

当二进制补码数扩展到更多位数时，需要将符号位复制到所有的扩展高位中。这个过程称为符号扩展（sign extension）。例如：数字3和-3的二进制补码表示分别为0011和1101。将这两个数扩展为7位时，可以将符号位复制到新的高3位中，分别得到0000011和1111101。

### 数制的比较

3中最常见的二进制分别为：

- 无符号数

- 二进制补码

- 带符号的原码

3中系统中N位数的表示范围：

| 数制     | 表示范围                          |
| ------ | ----------------------------- |
| 无符号的原码 | $[0, 2^{N-1}]$                |
| 带符号的原码 | $[-2^{N-1} + 1, 2^{N-1} - 1]$ |
| 二进制补码  | $[-2^{N-1}, 2^{N-1} - 1]$     |

二进制补码可以表示正数和负数，而且可以使用普通的加法。随意这种编码方式最方便。减法采用将减数取反（也采用二进制补码）再与被减数相加的方法实现。

## 1.5 逻辑门

逻辑门（logic gate）是最简单的数字电路，它们可以接收一个或多个二进制输入并产生一个二进制输出。

逻辑门用表示出输入和输出的符号画出。输入通常画在左边（或上部），输出通常画在右边（或下部）。输入和输出之间的关系由真值表或布尔表达式描述。

真值表（truth table）的左边列出输入，右边列出对应的输出，而且每种可能的输入组合对应一行。

布尔表达式（Boolean equation）是基于二进制变量的数学表达式。

### 1.5.1 非门

非门（NOT gate）有一个输入A和一个输出Y。非门的输出是输入的反。

非门也称为反相器（inverter）。

布尔表达式：

- $Y=\bar{A}$
- $Y=A^{'}$
- $Y=\overline A$
- $Y=!A$
- $Y=\sim A$

真值表：

| A   | Y   |
| --- | --- |
| 0   | 1   |
| 1   | 0   |

### 1.5.2 缓冲器

另一种单输入逻辑门称为缓冲器（buffer），它仅仅将输入复制到输出。

真值表：

| A   | Y   |
| --- | --- |
| 0   | 0   |
| 1   | 1   |

### 1.5.3 与门

与门（AND gate）在所有输入A和B都为TRUE时，输出Y才为TRUE，否则输出为FALSE。

布尔表达式：

- $Y=A \cdot B$
- $Y=AB$
- $Y=A \cap B$

真值表：

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 1   |

### 1.5.4 或门

或门（OR gate）中只要输入A和B中有一个为TRUE，输出Y就为TRUE。

布尔表达式：

- $Y=A + B$

- $Y=A \cup B$

真值表：

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 1   |

### 1.5.5 其他两输入逻辑门

#### 异或门

异或门（exclusive OR，XOR）的输入A和B中有且仅有一个输入为TRUE时，输出为TRUE。

布尔表达式：

- $Y=A \oplus B$

真值表：

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 0   |

#### 与非门

与非门（NAND）执行与非操作，它的所有输入为TRUE时输出才为FALSE，其他情况输出都为TRUE。

布尔表达式：

- $Y=\overline{AB}$

真值表：

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 1   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 0   |

#### 或非门

或非门（NOR）执行或非操作，它在输入A和B都不为TRUE时才输出TRUE。

布尔表达式：

- $Y=\overline {A+B}$

真值表：

| A   | B   | Y   |
| --- | --- | --- |
| 0   | 0   | 1   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 0   |
